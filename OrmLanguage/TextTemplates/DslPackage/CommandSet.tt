<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ output extension=".cs" #>
<#
	string dslName = this.Dsl.Name;
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslShell = global::Microsoft.VisualStudio.Modeling.Shell;
using VSShell = global::Microsoft.VisualStudio.Shell;
using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;
using DslValidation = global::Microsoft.VisualStudio.Modeling.Validation;

namespace <#= CodeGenerationUtilities.GetPackageNamespace(this.Dsl) #>
{
	/// <summary>
	/// Double-derived class to allow easier code customization.
	/// </summary>
	internal partial class <#= dslName #>CommandSet : <#= dslName #>CommandSetBase
	{
		/// <summary>
		/// Constructs a new <#= dslName #>CommandSet.
		/// </summary>
		public <#= dslName #>CommandSet(global::System.IServiceProvider serviceProvider) 
			: base(serviceProvider)
		{
		}
	}

	/// <summary>
	/// Class containing handlers for commands supported by this DSL.
	/// </summary>
	internal abstract class <#= dslName #>CommandSetBase : DslShell::CommandSet
	{
		/// <summary>
		/// Constructs a new <#= dslName #>CommandSetBase.
		/// </summary>
		protected <#= dslName #>CommandSetBase(global::System.IServiceProvider serviceProvider) : base(serviceProvider)
		{
		}

		/// <summary>
		/// Provide the menu commands that this command set handles
		/// </summary>
		protected override global::System.Collections.Generic.IList<global::System.ComponentModel.Design.MenuCommand> GetMenuCommands()
		{
			// Get the standard commands
			global::System.Collections.Generic.IList<global::System.ComponentModel.Design.MenuCommand> commands = base.GetMenuCommands();

<#
	if(this.Dsl.Explorer != null || (this.Dsl.Editor.Validation != null && this.Dsl.Editor.Validation.UsesMenu))
	{
#>
			global::System.ComponentModel.Design.MenuCommand menuCommand;

<#
	}

	if(this.Dsl.Explorer != null)
	{
#>
			// Add command handler for the "view explorer" command in the top-level menu.
			// We use a ContextBoundMenuCommand because the visibility of this command is
			// based on whether or not the command context of our DSL editor is active. 
			menuCommand = new DslShell::CommandContextBoundMenuCommand(this.ServiceProvider,
				new global::System.EventHandler(OnMenuViewModelExplorer),
				Constants.View<#= dslName #>ExplorerCommand,
				typeof(<#= dslName #>EditorFactory).GUID);

			commands.Add(menuCommand);

<#
	}
	if ( this.Dsl.Editor.Validation != null && this.Dsl.Editor.Validation.UsesMenu ) 
	{ 
#>
			// Add handler for "Validate All" menu command (validates the entire model).
			menuCommand = new DslShell::DynamicStatusMenuCommand(new global::System.EventHandler(OnStatusValidateModel), 
				new global::System.EventHandler(OnMenuValidateModel),
				DslShell::CommonModelingCommands.ValidateModel);
			commands.Add(menuCommand);
			// Add handler for "Validate" menu command (validates the current selection).
			menuCommand = new DslShell::DynamicStatusMenuCommand(new global::System.EventHandler(OnStatusValidate), 
				new global::System.EventHandler(OnMenuValidate),
				DslShell::CommonModelingCommands.Validate);
			commands.Add(menuCommand);

<#
	}
#>
			return commands;
		}
<#
	if(this.Dsl.Explorer != null)
	{
#>
		/// <summary>
		/// Command handler that shows the explorer tool window.
		/// </summary>
		internal virtual void OnMenuViewModelExplorer(object sender, global::System.EventArgs e)
		{
			<#= dslName #>ExplorerToolWindow explorer = this.<#= dslName #>ExplorerToolWindow;
			if (explorer != null)
			{
				explorer.Show();
			}
		}

<#
	}
	if ( this.Dsl.Editor.Validation != null && this.Dsl.Editor.Validation.UsesMenu ) 
	{ 
#>
		/// <summary>
		/// Status event handler for validating the model.
		/// </summary>
		internal virtual void OnStatusValidateModel(object sender, global::System.EventArgs e)
		{
			System.ComponentModel.Design.MenuCommand cmd = sender as System.ComponentModel.Design.MenuCommand;
			cmd.Enabled = cmd.Visible = true;
		}

		/// <summary>
		/// Handler for validating the model.
		/// </summary>
		internal virtual void OnMenuValidateModel(object sender, System.EventArgs e)
		{
			if (this.Current<#= dslName #>DocData != null && this.Current<#= dslName #>DocData.Store != null)
			{
				this.Current<#= dslName #>DocData.ValidationController.Validate(this.Current<#= dslName #>DocData.GetAllElementsForValidation(), DslValidation::ValidationCategories.Menu);
			}
		}
		
		/// <summary>
		/// Status event handler for validating the current selection.
		/// </summary>
		internal virtual void OnStatusValidate(object sender, System.EventArgs e)
		{
			global::System.ComponentModel.Design.MenuCommand cmd = sender as global::System.ComponentModel.Design.MenuCommand;
			cmd.Visible = cmd.Enabled = false;

			foreach (object selectedObject in this.CurrentSelection)
			{
				DslModeling::ModelElement element = GetValidationTarget(selectedObject);
					
				if (element != null)
				{
					cmd.Visible = cmd.Enabled = true;
					break;
				}
			}
		}

		/// <summary>
		/// Handler for validating the current selection.
		/// </summary>
		internal virtual void OnMenuValidate(object sender, global::System.EventArgs e)
		{
			if (this.Current<#= dslName #>DocData != null && this.Current<#= dslName #>DocData.Store != null)
			{
				System.Collections.Generic.List<DslModeling::ModelElement> elementList = new System.Collections.Generic.List<Microsoft.VisualStudio.Modeling.ModelElement>();
				DslModeling::DepthFirstElementWalker elementWalker = new DslModeling::DepthFirstElementWalker(new ValidateCommandVisitor(elementList), new DslModeling::EmbeddingVisitorFilter(), true);
				foreach (object selectedObject in this.CurrentSelection)
				{
					// Build list of elements embedded beneath the selected root.
					DslModeling::ModelElement element = GetValidationTarget(selectedObject);
					if (element != null && !elementList.Contains(element))
					{
						elementWalker.DoTraverse(element);
					}
				}

				this.Current<#= dslName #>DocData.ValidationController.Validate(elementList, DslValidation::ValidationCategories.Menu);
			}
		}
		
		/// <summary>
		/// Helper method to retrieve the target root element for validation from the selected object.
		/// </summary>
		protected static DslModeling::ModelElement GetValidationTarget(object selectedObject)
		{
			DslModeling::ModelElement element = null;
			DslDiagrams::PresentationElement presentation = selectedObject as DslDiagrams::PresentationElement;
			if (presentation != null)
			{
				if (presentation.Subject != null)
				{
					element = presentation.Subject;
				}
			}
			else
			{
				element = selectedObject as DslModeling::ModelElement;
			}
			return element;
		}
		
		#region ValidateCommandVisitor
		/// <summary>
		/// Helper class for building the list of elements to validate when the Validate command is executed.
		/// </summary>
		protected sealed class ValidateCommandVisitor : DslModeling::IElementVisitor
		{
			private System.Collections.Generic.IList<DslModeling::ModelElement> validationList;
 
			/// <summary>
			/// Construct a ValidateCommandVisitor that adds elements to be validated to the specified list.
			/// </summary>
			public ValidateCommandVisitor(System.Collections.Generic.IList<DslModeling::ModelElement> elementList)
			{
				this.validationList = elementList;
			}

			/// <summary>
			/// Called when traversal begins. 
			/// </summary>
			public void StartTraverse(Microsoft.VisualStudio.Modeling.ElementWalker walker) { }

			/// <summary>
			/// Called when traversal ends. 
			/// </summary>
			public void EndTraverse(Microsoft.VisualStudio.Modeling.ElementWalker walker) { }
			
			/// <summary>
			/// Called for each element in the traversal.
			/// </summary>
			public bool Visit(Microsoft.VisualStudio.Modeling.ElementWalker walker, Microsoft.VisualStudio.Modeling.ModelElement element)
			{
				this.validationList.Add(element);
				return true;
			}
		}
		#endregion
<#
	}
#>

		/// <summary>
		/// Returns the currently focused document.
		/// </summary>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
		protected <#= dslName #>DocData Current<#= dslName #>DocData
		{
			get
			{
				return this.MonitorSelection.CurrentDocument as <#= dslName #>DocData;
			}
		}

		/// <summary>
		/// Returns the currently focused document view.
		/// </summary>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
		protected <#= dslName #>DocView Current<#= dslName #>DocView
		{
			get
			{
				return this.MonitorSelection.CurrentDocumentView as <#= dslName #>DocView;
			}
		}

<#
	if(this.Dsl.Explorer != null)
	{
#>
		/// <summary>
		/// Returns the explorer tool window.
		/// </summary>
		protected <#= dslName #>ExplorerToolWindow <#= dslName #>ExplorerToolWindow
		{
			get
			{
				<#= dslName #>ExplorerToolWindow explorerWindow = null;
				DslShell::ModelingPackage package = this.ServiceProvider.GetService(typeof(VSShell::Package)) as DslShell::ModelingPackage;

				if (package != null)
				{
					explorerWindow = package.GetToolWindow(typeof(<#= dslName #>ExplorerToolWindow), true) as <#= dslName #>ExplorerToolWindow;
				}

				return explorerWindow;
			}
		}

		/// <summary>
		/// Returns the currently selected object in the model explorer.
		/// </summary>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
		protected object ExplorerSelection
		{
			get
			{
				object selection = null;
				<#= dslName #>ExplorerToolWindow explorerWindow = this.<#= dslName #>ExplorerToolWindow;
				
				if(explorerWindow != null)
				{
					foreach (object o in explorerWindow.GetSelectedComponents())
					{
						selection = o;
						break;
					}
				}

				return selection;
			}
		}
<#
	}
#>
	}
<#
	if(this.Dsl.Editor != null)
	{
		if (this.Dsl.Editor.CopyPasteGeneration != CopyPasteEnabling.NoGeneratedCopyPaste)
		{
#>
	/// <summary>
	/// Double-derived class to allow easier code customization.
	/// </summary>
	internal partial class <#= dslName #>ClipboardCommandSet : <#= dslName #>ClipboardCommandSetBase
	{
		/// <summary>
		/// Constructs a new <#= dslName #>ClipboardCommandSet.
		/// </summary>
		public <#= dslName #>ClipboardCommandSet(global::System.IServiceProvider serviceProvider)
			: base(serviceProvider)
		{
		}
	}

	/// <summary>
	/// Class containing handlers for cut/copy/paste commands supported by this DSL.
	/// </summary>
	internal abstract partial class <#= dslName #>ClipboardCommandSetBase : DslShell::ClipboardCommandSet
	{
		/// <summary>
		/// Constructs a new <#= dslName #>ClipboardCommandSetBase.
		/// </summary>
		protected <#= dslName #>ClipboardCommandSetBase(global::System.IServiceProvider serviceProvider)
			: base(serviceProvider)
		{
		}

		/// <summary>
		/// Provide the menu commands that this command set handles
		/// </summary>
		protected override global::System.Collections.Generic.IList<global::System.ComponentModel.Design.MenuCommand> GetMenuCommands()
		{
			// Get the standard commands
			var commands = new global::System.Collections.Generic.List<global::System.ComponentModel.Design.MenuCommand>(3);

			global::System.ComponentModel.Design.MenuCommand menuCommand;

			menuCommand = new DslShell::DynamicStatusMenuCommand(
				new global::System.EventHandler(this.OnStatusCut),
				new global::System.EventHandler(this.OnMenuCut),
				global::System.ComponentModel.Design.StandardCommands.Cut);
			commands.Add(menuCommand);

			menuCommand = new DslShell::DynamicStatusMenuCommand(
				new global::System.EventHandler(this.OnStatusCopy),
				new global::System.EventHandler(this.OnMenuCopy),
				global::System.ComponentModel.Design.StandardCommands.Copy);
			commands.Add(menuCommand);

			menuCommand = new DslShell::DynamicStatusMenuCommand(
				new global::System.EventHandler(this.OnStatusPaste),
				new global::System.EventHandler(this.OnMenuPaste),
				global::System.ComponentModel.Design.StandardCommands.Paste);
			commands.Add(menuCommand);

			return commands;
		}

<#
			if (CodeGenerationUtilities.GetDesigner(this.Dsl) == null && this.DslLibrary.Shapes.Count > 0)
			{
				// The designer has a custom editor, so we need to work around a bug in the runtime ClipboardCommandSet which assumes
				// there is a diagram and shapes in the Copy command implementation, and it tries to use these to copy a bitmap image
				// generating a null ref exception
#>
		/// <summary>
		/// Method to resolve shapes to be included in the Bitmap/Emf copied to the Clipboard. Using the DataObject enables one to align 
		/// the set of elements that are copied with those included in the copied image, otherwise it might be that one selects two 
		/// shapes but not the connector between them, and that connector is copied with the elements, but not as part of the image
		/// </summary>
		/// <remarks>We have no diagram, so override this to return an empty collection, which will suppress the standard bitmap copy</remarks>
		/// <param name="data">IDataObject which contained the ElementGroupPrototype</param>
		/// <param name="elements">Elements to be copied into the EGP</param>
		/// <returns>Collection of shapes to be exported as bitmap/emf to the clipboard</returns>
		protected override global::System.Collections.Generic.IEnumerable<DslDiagrams::ShapeElement> ResolveExportedShapesForClipboardImages(global::System.Windows.Forms.IDataObject data, global::System.Collections.Generic.IEnumerable<DslModeling::ModelElement> elements)
		{
			return new global::System.Collections.Generic.List<DslDiagrams::ShapeElement>();
		}

<#
			}
#>
		/// <summary>
		/// Determines whether Cut menu item should be visible and if so, enabled.
		/// </summary>
		/// <param name="sender">The sender of the message</param>
		/// <param name="args">empty</param>
		private void OnStatusCut(object sender, global::System.EventArgs args)
		{
			System.ComponentModel.Design.MenuCommand cmd = sender as System.ComponentModel.Design.MenuCommand;
			this.ProcessOnStatusCutCommand(cmd);
		}

		/// <summary>
		/// Determines whether Copy menu item should be visible and if so, enabled.
		/// </summary>
		/// <param name="sender">The sender of the message</param>
		/// <param name="args">empty</param>
		private void OnStatusCopy(object sender, global::System.EventArgs args)
		{
			System.ComponentModel.Design.MenuCommand cmd = sender as System.ComponentModel.Design.MenuCommand;
			this.ProcessOnStatusCopyCommand(cmd);
		}

		/// <summary>
		/// Updates the UI for the Paste command
		/// </summary>
		/// <param name="sender">The sender of the message</param>
		/// <param name="args">Message parameters</param>
		private void OnStatusPaste(object sender, global::System.EventArgs args)
		{
			System.ComponentModel.Design.MenuCommand cmd = sender as System.ComponentModel.Design.MenuCommand;
			this.ProcessOnStatusPasteCommand(cmd);
		}

		/// <summary>
		/// Event handler to cut the selected objects to the clipboard then delete the original.
		/// </summary>
		/// <param name="sender">The MenuCommand selected.</param>
		/// <param name="args">not used</param>
		private void OnMenuCut(object sender, global::System.EventArgs args)
		{
			this.ProcessOnMenuCutCommand();
		}

		/// <summary>
		/// Event handler to copy the selected objects to the clipboard.
		/// </summary>
		/// <param name="sender">The MenuCommand selected.</param>
		/// <param name="args">not used</param>
		private void OnMenuCopy(object sender, global::System.EventArgs args)
		{
			this.ProcessOnMenuCopyCommand();
		}

		/// <summary>
		/// Event handler to paste a copy of the object on the clipboard.
		/// </summary>
		/// <param name="sender">The MenuCommand selected.</param>
		/// <param name="args">not used</param>
		private void OnMenuPaste(object sender, global::System.EventArgs args)
		{
			this.ProcessOnMenuPasteCommand();
		}
	}
<# 
		}
	}
#>
}

