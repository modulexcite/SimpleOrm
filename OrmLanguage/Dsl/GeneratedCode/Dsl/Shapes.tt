<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Drawing" #>
<#@ import namespace="System.Drawing.Drawing2D" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ assembly name="System.Drawing" #>
<#@ include file="Dsl\DomainClass.tt" #>
<#@ include file="Dsl\DomainProperty.tt" #>
<#@ include file="Dsl\DomainRole.tt" #>
<#@ include file="Dsl\Utilities.tt" #>
<#@ include file="Dsl\DiagramUtilities.tt" #>
<#@ include file="Dsl\PathMerge.tt" #>
<#@ include file="Dsl\Merge.tt" #>
<#@ output extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<#
	if (this.DslLibrary.Shapes.Count == 0)
	{
#>
//
// This file is empty because the DSL definition does not define any Shapes.
//
<#
	}
	else
	{
#>

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDesign = global::Microsoft.VisualStudio.Modeling.Design;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;

<#
		DomainClassCodeGenerator constructorGenerator = new DomainClassCodeGenerator(this.GenerateDiagramElementConstructor);

		foreach(BaseShape shape in DslLibrary.Shapes)
		{
			string baseClass;
			
			if(shape.BaseClass != null)
			{
				baseClass = shape.BaseClass.GetFullName(true);
			}
			else if(shape is CompartmentShape)
			{
				baseClass = "DslDiagrams::CompartmentShape";
			}
			else if(shape is ImageShape)
			{
				baseClass = "DslDiagrams::ImageShape";
			}
			else if(shape is SwimLane)
			{
				baseClass = "DslDiagrams::SwimlaneShape";
			}
			else if(shape is Port)
			{
				baseClass = "DslDiagrams::Port";
			}
			else // GeometryShape
			{
				baseClass = "DslDiagrams::NodeShape";
			}
			
			DomainClassCodeGenerator codeGenerator;
			if(shape is CompartmentShape)
			{
				codeGenerator = new DomainClassCodeGenerator(this.GenerateCompartmentShape);
			}
			else if(shape is ImageShape)
			{
				codeGenerator = new DomainClassCodeGenerator(this.GenerateImageShape);
			}
			else if(shape is SwimLane)
			{
				codeGenerator = new DomainClassCodeGenerator(this.GenerateSwimlane);
			}
			else  // GeometryShape
			{
				codeGenerator = new DomainClassCodeGenerator(this.GenerateShape);
			}
			
			GenerateDomainClass(shape, baseClass, codeGenerator, constructorGenerator, null);
		}
	}
#>

<#+
// 
// Basic shape code generation
//
	
private void GenerateShape(DomainClass domainClass, object context)
{
	Shape shape = domainClass as Shape;
	if(shape==null)
	{
		return;
	}

	GenerateDiagramElementBoilerplate(shape);
	GenerateBaseShapeSizes(shape, shape.InitialWidth, shape.InitialHeight);
#>
#region Shape styles
<#+
	// defaults here match those in StyleSetApplication.cs
	Shape baseShape = shape.BaseClass as Shape;
	bool customOutlineColor = ((shape.OutlineColor != System.Drawing.Color.Black) || (baseShape != null && baseShape.OutlineColor != shape.OutlineColor));
	bool customOutlineDashStyle = ((shape.OutlineDashStyle != DashStyle.Solid) || (baseShape != null && baseShape.OutlineDashStyle != shape.OutlineDashStyle));
	bool customOutlineThickness = ((shape.OutlineThickness != 0.03125) || (baseShape != null && baseShape.OutlineThickness != shape.OutlineThickness));
	bool customFillColor = ((shape.FillColor != System.Drawing.Color.White) || (baseShape != null && baseShape.FillColor != shape.FillColor));
	bool customTextColor = ((shape.TextColor != System.Drawing.Color.Black) || (baseShape != null && baseShape.TextColor != shape.TextColor));
	
	// build list of custom font ids
	Dictionary<string, KeyValuePair<float, FontStyle>> customFonts = new Dictionary<string, KeyValuePair<float, FontStyle>>();
	foreach(Decorator decorator in shape.Decorators)
	{
		TextDecorator textDecorator = decorator as TextDecorator;
		if(textDecorator != null)
		{
			string fontId = GetFontId(textDecorator);
			if(fontId != null && !customFonts.ContainsKey(fontId))
			{
				customFonts[fontId] = new KeyValuePair<float, FontStyle>(textDecorator.FontSize, textDecorator.FontStyle);
			}
		}
	}
	
	if(customOutlineColor || 
		customOutlineDashStyle || 
		customOutlineThickness || 
		customFillColor ||
		customTextColor ||
		customFonts.Count > 0)
	{
#>
/// <summary>
/// Initializes style set resources for this shape type
/// </summary>
/// <param name="classStyleSet">The style set for this shape class</param>
protected override void InitializeResources(DslDiagrams::StyleSet classStyleSet)
{
	base.InitializeResources(classStyleSet);
	
<#+
		if(customOutlineColor || customOutlineDashStyle || customOutlineThickness)
		{
#>
	// Outline pen settings for this shape.
	DslDiagrams::PenSettings outlinePen = new DslDiagrams::PenSettings();
<#+
			if(customOutlineColor)
			{
#>
	outlinePen.Color = <#= MakeColorInitializer(shape.OutlineColor) #>;
<#+
			}
			if(customOutlineDashStyle)
			{
#>
	outlinePen.DashStyle = global::System.Drawing.Drawing2D.DashStyle.<#= shape.OutlineDashStyle #>;
	// Property:
	//	private static ArrayList customOutlineDashPattern;
	//	protected static ArrayList CustomOutlineDashPattern
	//	{
	//		get
	//		{
	//			if(customOutlineDashPattern == null)
	//				customOutlineDashPattern = new ArrayList(new float[] { 4.0F, 2.0F, 1.0F, 3.0F });
	//			return customOutlineDashPattern;
	//		}
	//	}
	// must be implemented in a partial class of <#= shape.GetFullName(false) #>. This property should
	// return an ArrayList of float values containing the custom DashPattern to use for this shape.
	outlinePen.DashPattern = <#= shape.GetFullName(true) #>.CustomOutlineDashPattern;
<#+
			}
			if(customOutlineThickness)
			{
#>
	outlinePen.Width = <#= shape.OutlineThickness #>F;
<#+
			}
#>
	classStyleSet.OverridePen(DslDiagrams::DiagramPens.ShapeOutline, outlinePen);
<#+
		}
#>

<#+
		if(customFillColor)
		{
#>
	// Fill brush settings for this shape.
	DslDiagrams::BrushSettings backgroundBrush = new DslDiagrams::BrushSettings();
	backgroundBrush.Color = <#= MakeColorInitializer(shape.FillColor) #>;
	classStyleSet.OverrideBrush(DslDiagrams::DiagramBrushes.ShapeBackground, backgroundBrush);

<#+
		}

		if(customTextColor)
		{
#>
	// Text brush settings for this shape.
	DslDiagrams::BrushSettings textBrush = new DslDiagrams::BrushSettings();
	textBrush.Color = <#= MakeColorInitializer(shape.TextColor) #>;
	classStyleSet.OverrideBrush(DslDiagrams::DiagramBrushes.ShapeText, textBrush);

<#+
		}
		
		if(customFonts.Count > 0)
		{
#>
	// Custom font styles
	DslDiagrams::FontSettings fontSettings;
<#+
			foreach(string fontId in customFonts.Keys)
			{
				KeyValuePair<float, FontStyle> fontSettings = customFonts[fontId];
#>
	fontSettings = new DslDiagrams::FontSettings();
	fontSettings.Style = <#= CodeGenerationUtilities.GenerateFontStyle(fontSettings.Value) #>;
	fontSettings.Size = <#= fontSettings.Key #>/72.0F;
	classStyleSet.AddFont(new DslDiagrams::StyleSetResourceId(string.Empty, "<#= fontId #>"), DslDiagrams::DiagramFonts.ShapeText, fontSettings);
<#+
			}
		}
#>
}

<#+
	}

	// Compartment shapes and geometry shapes have separate Geometry properties.
	string geometry = null;
	GeometryShape geometryShape = shape as GeometryShape;
	if(geometryShape != null)
	{
		geometry = geometryShape.Geometry.ToString();
	}
	else 
	{
		CompartmentShape compartmentShape = shape as CompartmentShape;
		if(compartmentShape != null)
		{
			geometry = compartmentShape.Geometry.ToString();
		}
	}
	
	// override the default (true for Rectangle and RoundedRectangle) if user explicitly specifies shape should not have a gradient.
	if(!(shape is ImageShape) && (geometry=="Rectangle" || geometry=="RoundedRectangle"))
	{
		if(shape.FillGradientMode==FillGradientMode.None)
		{
#>
/// <summary>
/// Indicates whether this shape displays a background gradient.
/// </summary>
public override bool HasBackgroundGradient
{
	get
	{
		return false;
	}
}
<#+
		}
		else
		{
#>
/// <summary>
/// Indicates whether this shape displays a background gradient.
/// </summary>
public override bool HasBackgroundGradient
{
	get
	{
		return true;
	}
}

<#+
			if(shape.FillGradientMode!=FillGradientMode.Vertical || shape.ExposesFillGradientMode)
			{
				if(shape.ExposesFillGradientMode)
				{
#>
private global::System.Drawing.Drawing2D.LinearGradientMode fillGradientMode = global::System.Drawing.Drawing2D.LinearGradientMode.<#= shape.FillGradientMode #>;

<#+
				}
#>
/// <summary>
/// Indicates the direction of the gradient.
/// </summary>
public override global::System.Drawing.Drawing2D.LinearGradientMode BackgroundGradientMode
{
	get
	{
<#+
				if(shape.ExposesFillGradientMode)
				{
#>
		return this.fillGradientMode;
<#+
				}
				else
				{
#>
		return global::System.Drawing.Drawing2D.LinearGradientMode.<#= shape.FillGradientMode #>;
<#+
				}
#>
	}
}
<#+
			}
		}
	}
	Shape shapeBase = shape.BaseClass as Shape;
	if(shape.HasDefaultConnectionPoints || (shapeBase != null && shapeBase.HasDefaultConnectionPoints != shape.HasDefaultConnectionPoints))
	{
#>
/// <summary>
/// Indicates whether the shape requires connection points.
/// </summary>
public override bool HasConnectionPoints
{
	get
	{
		return <#= shape.HasDefaultConnectionPoints ? "true" : "false" #>;
	}
}

<#+
		if(shape.HasDefaultConnectionPoints)
		{
#>
/// <summary>
/// Ensures that four default connection points exist, one at the midpoint of each side of the shape.
/// </summary>
/// <remarks>
/// This method is called each time a connector is created, but connection points only need to be defined once.
/// </remarks>
/// <param name="link">Connector which will be connected to this shape.</param>
public override void EnsureConnectionPoints(DslDiagrams::LinkShape link)
{
	if (this.ConnectionPoints.Count == 0)
	{
		DslDiagrams::RectangleD absoluteBoundingBox = this.AbsoluteBoundingBox;
		this.CreateConnectionPoint(new DslDiagrams::PointD(absoluteBoundingBox.Center.X, absoluteBoundingBox.Bottom));
		this.CreateConnectionPoint(new DslDiagrams::PointD(absoluteBoundingBox.Center.X, absoluteBoundingBox.Top));
		this.CreateConnectionPoint(new DslDiagrams::PointD(absoluteBoundingBox.Left, absoluteBoundingBox.Center.Y));
		this.CreateConnectionPoint(new DslDiagrams::PointD(absoluteBoundingBox.Right, absoluteBoundingBox.Center.Y));
	}
}

<#+
		}
	}
	
	if(geometry != null && geometry != "Rectangle")
	{
#>
/// <summary>
/// Specifies the geometry used by this shape
/// </summary>
public override DslDiagrams::ShapeGeometry ShapeGeometry
{
	get
	{
		return DslDiagrams::ShapeGeometries.<#= geometry #>;
	}
}
<#+
	}
#>
#endregion
<#+
	bool hasCustomStoredProperties = (shape.ExposesOutlineColorAsProperty || shape.ExposesFillColorAsProperty || shape.ExposesOutlineDashStyleAsProperty || shape.ExposesOutlineThicknessAsProperty || shape.ExposesFillGradientMode);
	if(hasCustomStoredProperties)
	{
#>
#region Custom storage for shape properties that appear in the property grid
<#+
		if(shape.ExposesOutlineColorAsProperty)
		{
			// custom-stored domain property to represent outline color should exist as part of shape definition, just generate getter/setter here
#>
/// <summary>
/// Custom storage for domain property OutlineColor.
/// </summary>
private global::System.Drawing.Color GetOutlineColorValue()
{
	DslDiagrams::PenSettings settings = this.StyleSet.GetOverriddenPenSettings(DslDiagrams::DiagramPens.ShapeOutline);
	if(settings != null && settings.IsOverridden(DslDiagrams::PenSettingsFlags.Color))
	{
		return settings.Color;
	}
	return <#= MakeColorInitializer(shape.OutlineColor) #>;
}

/// <summary>
/// Custom storage for domain property OutlineColor.
/// </summary>
private void SetOutlineColorValue(global::System.Drawing.Color newValue)
{
	DslDiagrams::PenSettings settings = this.StyleSet.GetOverriddenPenSettings(DslDiagrams::DiagramPens.ShapeOutline);
	if(settings == null) settings = new DslDiagrams::PenSettings();
	settings.Color = newValue;
	this.StyleSet.OverridePen(DslDiagrams::DiagramPens.ShapeOutline, settings);
	this.Invalidate();
}

<#+
		}
		
		if(shape.ExposesFillColorAsProperty)
		{
			// custom-stored domain property to represent fill color should exist as part of shape definition, just generate getter/setter here
#>
/// <summary>
/// Custom storage for domain property FillColor.
/// </summary>
private global::System.Drawing.Color GetFillColorValue()
{
	DslDiagrams::BrushSettings settings = this.StyleSet.GetOverriddenBrushSettings(DslDiagrams::DiagramBrushes.ShapeBackground);
	if(settings != null && settings.IsOverridden(DslDiagrams::BrushSettingsFlags.Color))
	{
		return settings.Color;
	}
	return <#= MakeColorInitializer(shape.FillColor) #>;
}

/// <summary>
/// Custom storage for domain property FillColor.
/// </summary>
private void SetFillColorValue(global::System.Drawing.Color newValue)
{
	DslDiagrams::BrushSettings settings = this.StyleSet.GetOverriddenBrushSettings(DslDiagrams::DiagramBrushes.ShapeBackground);
	if(settings == null) settings = new DslDiagrams::BrushSettings();
	settings.Color = newValue;
	this.StyleSet.OverrideBrush(DslDiagrams::DiagramBrushes.ShapeBackground, settings);
	this.Invalidate();
}

<#+
		}
		
		if(shape.ExposesTextColor)
		{
			// custom-stored domain property to represent text color should exist as part of shape definition, just generate getter/setter here
#>
/// <summary>
/// Custom storage for domain property FillColor.
/// </summary>
private global::System.Drawing.Color GetTextColorValue()
{
	DslDiagrams::BrushSettings settings = this.StyleSet.GetOverriddenBrushSettings(DslDiagrams::DiagramBrushes.ShapeText);
	if(settings != null && settings.IsOverridden(DslDiagrams::BrushSettingsFlags.Color))
	{
		return settings.Color;
	}
	return <#= MakeColorInitializer(shape.TextColor) #>;
}

/// <summary>
/// Custom storage for domain property FillColor.
/// </summary>
private void SetTextColorValue(global::System.Drawing.Color newValue)
{
	DslDiagrams::BrushSettings settings = this.StyleSet.GetOverriddenBrushSettings(DslDiagrams::DiagramBrushes.ShapeText);
	if(settings == null) settings = new DslDiagrams::BrushSettings();
	settings.Color = newValue;
	this.StyleSet.OverrideBrush(DslDiagrams::DiagramBrushes.ShapeText, settings);
	this.Invalidate();
}

<#+
		}
		
		if(shape.ExposesOutlineDashStyleAsProperty)
		{
			// custom-stored domain property to represent outline dash style should exist as part of shape definition, just generate getter/setter here
#>
/// <summary>
/// Custom storage for domain property OutlineDashStyle.
/// </summary>
private global::System.Drawing.Drawing2D.DashStyle GetOutlineDashStyleValue()
{
	DslDiagrams::PenSettings settings = this.StyleSet.GetOverriddenPenSettings(DslDiagrams::DiagramPens.ShapeOutline);
	if(settings != null && settings.IsOverridden(DslDiagrams::PenSettingsFlags.DashStyle))
	{
		return settings.DashStyle;
	}
	return global::System.Drawing.Drawing2D.DashStyle.<#= shape.OutlineDashStyle #>;
}

/// <summary>
/// Custom storage for domain property OutlineDashStyle.
/// </summary>
private void SetOutlineDashStyleValue(global::System.Drawing.Drawing2D.DashStyle newValue)
{
	DslDiagrams::PenSettings settings = this.StyleSet.GetOverriddenPenSettings(DslDiagrams::DiagramPens.ShapeOutline);
	if(settings == null) settings = new DslDiagrams::PenSettings();
	settings.DashStyle = newValue;
	this.StyleSet.OverridePen(DslDiagrams::DiagramPens.ShapeOutline, settings);
	this.Invalidate();
}

<#+
		}
		
		if(shape.ExposesOutlineThicknessAsProperty)
		{
			// custom-stored domain property to represent outline thickness should exist as part of shape definition, just generate getter/setter here
#>
/// <summary>
/// Custom storage for domain property OutlineThickness.
/// </summary>
private float GetOutlineThicknessValue()
{
	DslDiagrams::PenSettings settings = this.StyleSet.GetOverriddenPenSettings(DslDiagrams::DiagramPens.ShapeOutline);
	if(settings != null && settings.IsOverridden(DslDiagrams::PenSettingsFlags.Width))
	{
		return settings.Width;
	}
	return <#= shape.OutlineThickness #>f;
}

/// <summary>
/// Custom storage for domain property OutlineThickness.
/// </summary>
private void SetOutlineThicknessValue(float newValue)
{
	DslDiagrams::PenSettings settings = this.StyleSet.GetOverriddenPenSettings(DslDiagrams::DiagramPens.ShapeOutline);
	if(settings == null) settings = new DslDiagrams::PenSettings();
	settings.Width = newValue;
	this.StyleSet.OverridePen(DslDiagrams::DiagramPens.ShapeOutline, settings);
	this.Invalidate();
}

<#+
		}
		
		if(shape.ExposesFillGradientMode)
		{
			// custom-stored domain property to represent outline thickness should exist as part of shape definition, just generate getter/setter here
#>
/// <summary>
/// Custom storage for domain property FillGradientMode.
/// </summary>
private global::System.Drawing.Drawing2D.LinearGradientMode GetFillGradientModeValue()
{
	return this.fillGradientMode;
}

/// <summary>
/// Custom storage for domain property FillGradientMode.
/// </summary>
private void SetFillGradientModeValue(global::System.Drawing.Drawing2D.LinearGradientMode newValue)
{
	this.fillGradientMode = newValue;
	this.Invalidate();
}

<#+
		}
#>
#endregion
<#+
	}
#>

<#+
	if(shape.Decorators.Count > 0)
	{
#>
#region Decorators
<#+
	GenerateDecorators(shape);	
	
	BaseShape baseBaseShape = shape.BaseClass as BaseShape;
	if(baseBaseShape == null || baseBaseShape.Decorators.Count == 0)
	{	
#>
/// <summary>
/// Ensure outer decorators are placed appropriately.  This is called during view fixup,
/// after the shape has been associated with the model element.
/// </summary>
public override void OnBoundsFixup(DslDiagrams::BoundsFixupState fixupState, int iteration, bool createdDuringViewFixup)
{
	base.OnBoundsFixup(fixupState, iteration, createdDuringViewFixup);
	
	if(iteration == 0)
	{
		foreach(DslDiagrams::Decorator decorator in this.Decorators)
		{
			if(decorator.RequiresHost)
			{
				decorator.RepositionHostShape(decorator.GetHostShape(this));
			}
		}
	}
}
<#+
	}
#>
#endregion
<#+
	}
	
	if(shape.TooltipType != TooltipType.None)
	{
		GenerateTooltipCode(shape);
	}
}
#>

<#+
//
// Compartment shape code generation.
//

private void GenerateCompartmentShape(DomainClass domainClass, object context)
{
	CompartmentShape shape = domainClass as CompartmentShape;
	if(shape==null)
	{
		return;
	}
	GenerateShape(shape, null);
#>
#region CompartmentShape code
<#+
	
	// only generate code if different from the default
	if(shape.IsSingleCompartmentHeaderVisible)
	{
#>
/// <summary>
/// Returns a value indicating whether compartment header should be visible if there is only one of them.
/// </summary>
public override bool IsSingleCompartmentHeaderVisible
{
	get { return true; }
}
<#+
	}
#>

private static DslDiagrams::CompartmentDescription[] compartmentDescriptions;

/// <summary>
/// Gets an array of CompartmentDescription for all compartments shown on this shape
/// (including compartments defined on base shapes).
/// </summary>
/// <returns></returns>
public override DslDiagrams::CompartmentDescription[] GetCompartmentDescriptions()
{
	if(compartmentDescriptions == null)
	{
		// Initialize the array of compartment descriptions if we haven't done so already. 
		// First we get any compartment descriptions in base shapes, and add on any compartments
		// that are defined on this shape. 
		DslDiagrams::CompartmentDescription[] baseCompartmentDescriptions = base.GetCompartmentDescriptions();
		
		int localCompartmentsOffset = 0;
		if(baseCompartmentDescriptions!=null)
		{
			localCompartmentsOffset = baseCompartmentDescriptions.Length;
		}
		compartmentDescriptions = new DslDiagrams::ElementListCompartmentDescription[<#= shape.Compartments.Count #>+localCompartmentsOffset];
		
		if(baseCompartmentDescriptions!=null)
		{
			baseCompartmentDescriptions.CopyTo(compartmentDescriptions, 0);	
		}
<#+
	// Create compartment descriptions for all compartment shapes
	int i=0;
	foreach (Compartment compartment in shape.Compartments)
	{
		GenerateCompartmentDescription(i++, compartment);
	}
#>
	}
	
	return <#=shape.Name#>.compartmentDescriptions;
}

private static global::System.Collections.Generic.Dictionary<global::System.Type, DslDiagrams::CompartmentMapping[]> compartmentMappings;

/// <summary>
/// Gets an array of CompartmentMappings for all compartments displayed on this shape
/// (including compartment maps defined on base shapes). 
/// </summary>
/// <param name="melType">The type of the DomainClass that this shape is mapped to</param>
/// <returns></returns>
protected override DslDiagrams::CompartmentMapping[] GetCompartmentMappings(global::System.Type melType)
{
	if(melType==null) throw new global::System.ArgumentNullException("melType");
	
	if(compartmentMappings==null)
	{
		// Initialize the table of compartment mappings if we haven't done so already. 
		// The table contains an array of CompartmentMapping for every Type that this
		// shape can be mapped to. 
		compartmentMappings = new global::System.Collections.Generic.Dictionary<global::System.Type, DslDiagrams::CompartmentMapping[]>();
<#+
	IList<CompartmentShapeMap> compartmentShapeMaps = new LinkedElementCollection<CompartmentShapeMap>(shape, CompartmentShapeMapReferencesCompartmentShape.ShapeDomainRoleId);
	foreach(CompartmentShapeMap shapeMap in compartmentShapeMaps)
	{
#>
		{
			// First we get the mappings defined for the base shape, and add on any mappings defined for this
			// shape. 
			DslDiagrams::CompartmentMapping[] baseMappings = base.GetCompartmentMappings(typeof(<#= shapeMap.Class.GetFullName(true) #>));
			int localCompartmentMappingsOffset = 0;
			if(baseMappings!=null)
			{
				localCompartmentMappingsOffset = baseMappings.Length;
			}
			DslDiagrams::CompartmentMapping[] mappings = new DslDiagrams::CompartmentMapping[<#= shapeMap.CompartmentMaps.Count #>+localCompartmentMappingsOffset];
			
			if(baseMappings!=null)
			{
				baseMappings.CopyTo(mappings, 0);
			}
<#+
		int index = 0;
		foreach(CompartmentMap map in shapeMap.CompartmentMaps)
		{
			if(map.DisplaysCustomString)
			{
#>
			////////
			// CompartmentMap.DisplaysCustomString == true
			// Please provide the following method to get the string to be
			// displayed in the compartment list: 
			//
			// static string GetDisplayPropertyFrom<#= shapeMap.Class.Name.Replace('@','_') #>For<#= map.Compartment.Name #>(DslModeling::ModelElement element)
			////////
<#+
				if(map.PropertyDisplayed==null || map.PropertyDisplayed.Property==null)
				{
#>
			mappings[localCompartmentMappingsOffset+<#= index #>] = new DslDiagrams::ElementListCompartmentMapping(
																		"<#= map.Compartment.Name #>", 
																		<#= CodeGenerationUtilities.GetSegmentOutputType(map.ElementsDisplayed.Segments[map.ElementsDisplayed.Segments.Count-1]) #>.DomainClassId, 
																		GetElementsFrom<#= shapeMap.Class.Name.Replace('@','_') #>For<#= map.Compartment.Name #>, 
																		GetDisplayPropertyFrom<#= shapeMap.Class.Name.Replace('@','_') #>For<#= map.Compartment.Name #>,	// This method needs to be provided. Please see comment-block above.
																		null);		
<#+
				}
				else
				{
#>
			mappings[localCompartmentMappingsOffset+<#= index #>] = new DslDiagrams::ElementListCompartmentMapping(
																		"<#= map.Compartment.Name #>", 
																		<#= map.PropertyDisplayed.Property.Class.GetFullName(true) #>.<#= map.PropertyDisplayed.Property.Name #>DomainPropertyId, 
																		<#= CodeGenerationUtilities.GetSegmentOutputType(map.ElementsDisplayed.Segments[map.ElementsDisplayed.Segments.Count-1]) #>.DomainClassId, 
																		GetElementsFrom<#= shapeMap.Class.Name.Replace('@','_') #>For<#= map.Compartment.Name #>,
<#+
					if(map.PropertyDisplayed.PathToProperty==null || map.PropertyDisplayed.PathToProperty.Segments.Count==0)
					{
#>
																		null,
<#+
					}
					else
					{
#>
																		GetPropertyElementFrom<#= shapeMap.Class.Name.Replace('@','_') #>For<#= map.Compartment.Name #>,	// This method needs to be provided. Please see comment-block above.
<#+
					}
#>
																		GetDisplayPropertyFrom<#= shapeMap.Class.Name.Replace('@','_') #>For<#= map.Compartment.Name #>,	// This method needs to be provided. Please see comment-block above.
																		null);
<#+
				}
			}
			else
			{
#>
			mappings[localCompartmentMappingsOffset+<#= index #>] = new DslDiagrams::ElementListCompartmentMapping(
																		"<#= map.Compartment.Name #>", 
																		<#= map.PropertyDisplayed.Property.Class.GetFullName(true) #>.<#= map.PropertyDisplayed.Property.Name #>DomainPropertyId, 
																		<#= CodeGenerationUtilities.GetSegmentOutputType(map.ElementsDisplayed.Segments[map.ElementsDisplayed.Segments.Count-1]) #>.DomainClassId, 
																		GetElementsFrom<#= shapeMap.Class.Name.Replace('@','_') #>For<#= map.Compartment.Name #>,
<#+
					if(map.PropertyDisplayed.PathToProperty==null || map.PropertyDisplayed.PathToProperty.Segments.Count==0)
					{
#>
																		null,
<#+
					}
					else
					{
#>
																		GetPropertyElementFrom<#= shapeMap.Class.Name.Replace('@','_') #>For<#= map.Compartment.Name #>,	// This method needs to be provided. Please see comment-block above.
<#+
					}
#>
																		null,
																		null);
<#+
			}
			index++;
		}
#>
			compartmentMappings.Add(typeof(<#= shapeMap.Class.GetFullName(true) #>), mappings);
		}
<#+
	}
#>
	}
	
	// See if we can find the mapping being requested directly in the table. 
	DslDiagrams::CompartmentMapping[] returnValue;
	if(compartmentMappings.TryGetValue(melType, out returnValue))
	{
		return returnValue;
	}
	
	// If not, loop through the types in the table, and find the 'most derived' base
	// class of melType. 
	global::System.Type selectedMappedType = null;
	foreach(global::System.Type mappedType in compartmentMappings.Keys)
	{
		if(mappedType.IsAssignableFrom(melType) && (selectedMappedType==null || selectedMappedType.IsAssignableFrom(mappedType)))
		{
			selectedMappedType = mappedType;
		}
	}
	if(selectedMappedType!=null)
	{
		return compartmentMappings[selectedMappedType];
	}
	return new DslDiagrams::CompartmentMapping[] {};
}

	#region DomainPath traversal methods to get the list of elements to display in a compartment.
<#+
	foreach(CompartmentShapeMap shapeMap in compartmentShapeMaps)
	{
		foreach(CompartmentMap map in shapeMap.CompartmentMaps)
		{
#>
	internal static global::System.Collections.IList GetElementsFrom<#= shapeMap.Class.Name.Replace('@','_') #>For<#= map.Compartment.Name #>(DslModeling::ModelElement rootElement)
	{
<#+
			string inputType = CodeGenerationUtilities.GetSegmentInputType(map.ElementsDisplayed.Segments[0]);
#>
		<#= inputType #> root = (<#= inputType #>)rootElement;
<#+
			GenerateCollectionPathMethodBody(map.ElementsDisplayed, "root", "result");
			
			if(map.UsesCustomFilter)
			{
#>
		
		////////
		// CompartmentMap.UsesCustomFilter==true
		// Please provide a method with the following signature to filter the list of
		// elements to display in the compartment:
		// global::System.Collections.IList FilterElementsFrom<#= shapeMap.Class.Name #>For<#= map.Compartment.Name #>(global::System.Collections.IEnumerable elements) {}
		////////
		return FilterElementsFrom<#= shapeMap.Class.Name #>For<#= map.Compartment.Name #>(result);
<#+
			}
			else
			{			
#>
		return result;
<#+
			}
#>
	}
<#+
			if(map.PropertyDisplayed!=null && map.PropertyDisplayed.PathToProperty!=null && map.PropertyDisplayed.PathToProperty.Segments.Count>0)
			{
#>
	internal static DslModeling::ModelElement GetPropertyElementFrom<#= shapeMap.Class.Name.Replace('@','_') #>For<#= map.Compartment.Name #>(DslModeling::ModelElement element)
	{
<#+
			inputType = CodeGenerationUtilities.GetSegmentInputType(map.PropertyDisplayed.PathToProperty.Segments[0]);
#>
		<#= inputType #> root = (<#= inputType #>)element;
<#+
			GeneratePathMethodBody(map.PropertyDisplayed.PathToProperty, "root", "result");
#>
		return result;
	}
<#+
			}
		}
	}
#>
	#endregion

#endregion
<#+
}
#>

<#+
private void GenerateCompartmentDescription(int index, Compartment compartment)
{
	bool customTitleFont = HasCustomTitleFont(compartment);
	bool customEntryFont = HasCustomEntryFont(compartment);

#>
		{
<#+
	if(customTitleFont)
	{
#>
			DslDiagrams::FontSettings titleFont = new DslDiagrams::FontSettings();
			titleFont.Style = <#= CodeGenerationUtilities.GenerateFontStyle(compartment.TitleFontStyle) #>;
			titleFont.Size = <#= compartment.TitleFontSize #>/72.0F;
<#+
	}
	if(customEntryFont)
	{
#>
			DslDiagrams::FontSettings itemFont = new DslDiagrams::FontSettings();
			itemFont.Style = <#= CodeGenerationUtilities.GenerateFontStyle(compartment.EntryFontStyle) #>;
			itemFont.Size = <#= compartment.EntryFontSize #>/72.0F;
<#+
	}
#>
			string title = <#= compartment.Shape.DslLibrary.GetFullName(true) #>DomainModel.SingletonResourceManager.GetString("<#= compartment.Shape.Name #><#= compartment.Name #>Title");
			DslDiagrams::ElementListCompartmentDescription descriptor = new DslDiagrams::ElementListCompartmentDescription("<#=compartment.Name#>", title, 
				<#=MakeColorInitializer(compartment.TitleFillColor)#>, false, 
				<#=MakeColorInitializer(compartment.FillColor)#>, false,
				<#= customTitleFont ? "titleFont" : "null" #>, <#= customEntryFont ? "itemFont" : "null" #>,
				<#= compartment.DefaultExpandCollapseState==ExpandCollapseState.Expanded ? "false" : "true" #>);
<#+

	if (compartment.TitleTextColor != Color.Black) 
	{
#>
			descriptor.TitleTextColor = <#= MakeColorInitializer(compartment.TitleTextColor) #>;
<#+

	}
	if (compartment.EntryTextColor != Color.Black) 
	{
#>
			descriptor.ItemTextColor = <#= MakeColorInitializer(compartment.EntryTextColor) #>;
<#+

	}
#>
			compartmentDescriptions[localCompartmentsOffset+<#= index #>] = descriptor;
		}
<#+
}
#>

<#+
// 
// Image shape code generation
//
	
private void GenerateImageShape(DomainClass domainClass, object context)
{
	ImageShape shape = domainClass as ImageShape;
	if(shape==null)
	{
		return;
	}
	GenerateShape(shape, null);
	// only generate code if non-null (there may be a base shape where the image is specified)
	if(!String.IsNullOrEmpty(shape.Image))
	{
#>
/// <summary>
/// Provide the specific Image for this Shape class
/// </summary>
protected override global::System.Drawing.Image Image
{
	get
	{
		global::System.Resources.ResourceManager resourceManager = <#= shape.DslLibrary.GetFullName(true) #>DomainModel.SingletonResourceManager;
		return DslDiagrams::ImageHelper.GetImage(resourceManager.GetObject("<#=shape.Name#>Image"));
	}
}
<#+
	}
}
#>

<#+
// 
// Swimlane shape code generation
//

private void GenerateSwimlane(DomainClass domainClass, object context)
{
	SwimLane lane = domainClass as SwimLane;
	if(lane==null)
	{
		return;
	}
	
	GenerateDiagramElementBoilerplate(lane);
	GenerateBaseShapeSizes(lane, lane.InitialWidth, lane.InitialHeight);
#>
#region Shape styles
<#+
	
	// Only generate code if different from the default.
	if(String.Compare(lane.Alignment.ToString(), "Vertical", StringComparison.Ordinal) != 0)
	{
#>
/// <summary>
/// Gets the swimlane's alignment within the diagram: horizontal or vertical.
/// </summary>
public override DslDiagrams::SwimlaneAlignment Alignment
{
	get
	{
		return DslDiagrams.SwimlaneAlignment.<#= lane.Alignment #>;
	}
}

<#+
	}

	// mapped swimlanes should override ForwardDragDropToParent property to false.	
	if (SwimLaneMapReferencesSwimLane.GetSwimLaneMaps(lane).Count > 0)
	{
#>
/// <summary>
/// Returns false for this swimlane since it's mapped to a domain class.
/// </summary>
public override bool ForwardDragDropToParent
{
	get
	{
		return false;
	}
}

<#+
	}
	
	// defaults here match those in StyleSetApplication.cs
	bool customSeparatorColor = (lane.SeparatorColor != System.Drawing.Color.LightGray);
	bool customSeparatorLineStyle = (lane.SeparatorLineStyle != DashStyle.Dash);
	bool customSeparatorThickness = (lane.SeparatorThickness != 0.03125);
	bool customHeaderFillColor = (lane.HeaderFillColor != System.Drawing.Color.DarkGray);
	bool customBodyFillColor = (lane.BodyFillColor != System.Drawing.Color.White);
	bool customTextColor = (lane.TextColor != System.Drawing.Color.Black);
	
	// build list of custom font ids
	Dictionary<string, KeyValuePair<float, FontStyle>> customFonts = new Dictionary<string, KeyValuePair<float, FontStyle>>();
	foreach(Decorator decorator in lane.Decorators)
	{
		TextDecorator textDecorator = decorator as TextDecorator;
		if(textDecorator != null)
		{
			string fontId = GetFontId(textDecorator);
			if(fontId != null && !customFonts.ContainsKey(fontId))
			{
				customFonts[fontId] = new KeyValuePair<float, FontStyle>(textDecorator.FontSize, textDecorator.FontStyle);
			}
		}
	}
	
	if(customSeparatorColor || 
		customSeparatorLineStyle || 
		customSeparatorThickness || 
		customHeaderFillColor ||
		customBodyFillColor ||
		customTextColor ||
		customFonts.Count > 0)
	{
#>
/// <summary>
/// Initializes style set resources for this shape type
/// </summary>
/// <param name="classStyleSet">The style set for this shape class</param>
protected override void InitializeResources(DslDiagrams::StyleSet classStyleSet)
{
	base.InitializeResources(classStyleSet);
	
<#+
		if(customSeparatorColor || customSeparatorLineStyle || customSeparatorThickness)
		{
#>
	// Outline pen settings for this shape.
	DslDiagrams::PenSettings separatorPen = new DslDiagrams::PenSettings();
<#+
			if(customSeparatorColor)
			{
#>
	separatorPen.Color = <#= MakeColorInitializer(lane.SeparatorColor) #>;
<#+
			}
			if(customSeparatorLineStyle)
			{
#>
	separatorPen.DashStyle = global::System.Drawing.Drawing2D.DashStyle.<#= lane.SeparatorLineStyle #>;
<#+
			}
			if(customSeparatorThickness)
			{
#>
	separatorPen.Width = <#= lane.SeparatorThickness #>F;
<#+
			}
#>
	classStyleSet.OverridePen(DslDiagrams::DiagramPens.SwimlaneSeparator, separatorPen);
<#+
		}
#>

<#+
		if(customHeaderFillColor)
		{
#>
	// Fill brush settings for this swimlane's header.
	DslDiagrams::BrushSettings headerBrush = new DslDiagrams::BrushSettings();
	headerBrush.Color = <#= MakeColorInitializer(lane.HeaderFillColor) #>;
	classStyleSet.OverrideBrush(DslDiagrams::DiagramBrushes.SwimlaneHeaderBackground, headerBrush);

<#+
		}

		if(customBodyFillColor)
		{
#>
	// Fill brush settings for this swimlane's body.
	DslDiagrams::BrushSettings bodyBrush = new DslDiagrams::BrushSettings();
	bodyBrush.Color = <#= MakeColorInitializer(lane.BodyFillColor) #>;
	classStyleSet.OverrideBrush(DslDiagrams::DiagramBrushes.ShapeBackground, bodyBrush);

<#+
		}

		if(customTextColor)
		{
#>
	// Text brush settings for this swimlane.
	DslDiagrams::BrushSettings textBrush = new DslDiagrams::BrushSettings();
	textBrush.Color = <#= MakeColorInitializer(lane.TextColor) #>;
	classStyleSet.OverrideBrush(DslDiagrams::DiagramBrushes.ShapeText, textBrush);

<#+
		}
		
		if(customFonts.Count > 0)
		{
#>
	// Custom font styles
	DslDiagrams::FontSettings fontSettings;
<#+
			foreach(string fontId in customFonts.Keys)
			{
				KeyValuePair<float, FontStyle> fontSettings = customFonts[fontId];
#>
	fontSettings = new DslDiagrams::FontSettings();
	fontSettings.Style = <#= CodeGenerationUtilities.GenerateFontStyle(fontSettings.Value) #>;
	fontSettings.Size = <#= fontSettings.Key #>/72.0F;
	classStyleSet.AddFont(new DslDiagrams::StyleSetResourceId(string.Empty, "<#= fontId #>"), DslDiagrams::DiagramFonts.ShapeText, fontSettings);
<#+
			}
		}
#>
}
<#+
	}
#>
#endregion
<#+
	if(lane.Decorators.Count > 0)
	{
#>
#region Decorators
<#+
	GenerateDecorators(lane);
#>
#endregion
#region Auto-placement
/// <summary>
/// Indicate that child shapes should added through view fixup should be placed automatically.
/// </summary>
public override bool ShouldAutoPlaceChildShapes
{
	get
	{
		return true;
	}
}
#endregion
<#+
	}

	if(lane.TooltipType != TooltipType.None)
	{
		GenerateTooltipCode(lane);
	}
#>

<#+
}
#>

<#+
//
// Utility functions
//

public bool HasCustomTitleFont(Compartment compartment)
{
	if(compartment.TitleFontSize != 8 || compartment.TitleFontStyle != FontStyle.Regular)
	{
		return true;
	}
	
	return false;
}

public bool HasCustomEntryFont(Compartment compartment)
{
	if(compartment.EntryFontSize != 8 || compartment.EntryFontStyle != FontStyle.Regular)
	{
		return true;
	}
	
	return false;
}

public void GenerateBaseShapeSizes(BaseShape baseShape, double initialWidth, double initialHeight)
{
	BaseShape baseShapeBase = baseShape.BaseClass as BaseShape;
	
	bool generateDefaultSizeCode = true;
	DomainPropertyInfo widthProperty = this.DslLibrary.Store.DomainDataDirectory.GetDomainProperty(Shape.InitialWidthDomainPropertyId);
	DomainPropertyInfo heightProperty = this.DslLibrary.Store.DomainDataDirectory.GetDomainProperty(Shape.InitialHeightDomainPropertyId);
	
	// if set to default size, only generate default size code if there is no base shape (otherwise it gets picked up from the base).
	if(initialWidth.Equals(widthProperty.DefaultValue) && initialHeight.Equals(heightProperty.DefaultValue))
	{
		// don't generate default size code for image shapes, this is picked up from the image.
		generateDefaultSizeCode = (baseShapeBase == null && !(baseShape is ImageShape));
		
		// different default sizes for port shape
		if(generateDefaultSizeCode && baseShape is Port)
		{
			initialWidth = initialHeight = 0.125;
		}
	}
		
	GeometryShape geoShape = baseShape as GeometryShape;
	if (geoShape != null && geoShape.Geometry == ShapeGeometry.Circle)
	{
		initialHeight = initialWidth;
	}
	
	if(baseShapeBase == null || generateDefaultSizeCode)
	{
#>
#region Shape size
<#+
		if(generateDefaultSizeCode)
		{
#>

/// <summary>
/// Default size for this shape.
/// </summary>
public override DslDiagrams::SizeD DefaultSize
{
	get
	{
		return new DslDiagrams::SizeD(<#= initialWidth #>, <#=  initialHeight #>);
	}
}
<#+
		}
#>
#endregion
<#+
	}
}
#>