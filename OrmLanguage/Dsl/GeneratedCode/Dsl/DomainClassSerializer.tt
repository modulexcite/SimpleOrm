<#+
/// <summary>
/// Generates a serializer for the given DomainClass.
/// If serializer is generated, return the name of the generated serializer;
/// otherwise return empty string.
/// </summary>
private string GenerateDomainClassSerializer(XmlSerializationBehavior behavior, DomainClass domainClass, UniqueSerializerNameGenerator uniqueSerializerNameGenerator)
{
	string namespaceString = behavior.Namespace;
	string currentXmlNamespace = CodeGenerationUtilities.GetXmlSchemaNamespace(domainClass.DslLibrary);
	string classTypeString = domainClass.GetRelativeName (namespaceString, true);
	bool isRelationship = (domainClass is DomainRelationship);
	bool isAbstract = (domainClass.InheritanceModifier == InheritanceModifier.Abstract);

	bool isSealed = (domainClass.InheritanceModifier == InheritanceModifier.Sealed);
	bool monikerizationSupportOnly = false;
	bool readSupportOnly = false;

	if (isRelationship && isSealed && !CodeGenerationUtilities.UseFullForm(domainClass as DomainRelationship))
	{
		bool omitElement = CodeGenerationUtilities.OmitElement(domainClass as DomainRelationship);
		if (((DomainRelationship)domainClass).IsEmbedding)
		{	
			if (omitElement)
			{	// This relationship will not participate in Read/Write actions directly,
				// no need to generate serializer for it.
				return string.Empty;
			}
			else
			{	// Need to handle the case where the relationship is serialized in full-form, but should be in short-form, or vice versa.
				readSupportOnly = true;
			}
		}
		else
		{
			DomainRole targetRole = (domainClass as DomainRelationship).Target;
			DomainClass targetRolePlayer = targetRole.RolePlayer;
			MonikerData monikerData = MonikerDataCache[targetRolePlayer];
			if (monikerData.CanBeMonikerized)
			{
				// This relationship will not participate in Read/Write actions directly,
				// but we need to generate monikerization support.
				monikerizationSupportOnly = true;
				if (!omitElement)
				{	// Need to handle the case where the relationship is serialized in full-form, but should be in short-form, or vice versa.
					readSupportOnly = true;
				}
			}
			else
			{	// There's something wrong with this relationship. It's a reference relationship, but pointing to elements
				// that cannot be monikerized.
				return string.Empty;
			}
		}
	}

	string serializerGenerationClassName = uniqueSerializerNameGenerator.GetGenerationSerializerName (domainClass);
	string serializerClassName = uniqueSerializerNameGenerator.GetSerializerName (domainClass);
	string baseSerializerClassName = string.Empty;
	if (domainClass.BaseClass == null || BaseClassHelper.IsModelElement(domainClass.BaseClass))
		baseSerializerClassName = BaseClassHelper.Instance[domainClass.GetType()];
	else
	{
		DomainClass baseClass = domainClass.BaseClass;
		DslLibrary baseDsl = baseClass.DslLibrary;
		System.Diagnostics.Debug.Assert (baseDsl != null);
		if (baseDsl != null)
		{
			if (baseDsl.Id == domainClass.DslLibrary.Id)
			{	// Same DslLibrary, use the same UniqueSerializerNameGenerator.
				baseSerializerClassName = uniqueSerializerNameGenerator.GetSerializerName (baseClass);
			}
			else
			{	// Different Dsl, need to use a new UniqueSerializerNameGenerator.
				baseSerializerClassName = (new UniqueSerializerNameGenerator(baseDsl)).GetSerializerName (baseClass);
				// Also need to get base serializer namespace name;
				XmlSerializationBehavior baseBehavior = baseDsl.XmlSerializationBehavior;
				if (baseBehavior != null)
				{
					string baseNamespaceString = baseBehavior.Namespace;
					if (!string.IsNullOrEmpty(baseNamespaceString))
					{
						if (string.IsNullOrEmpty(namespaceString) || !string.Equals(namespaceString, baseNamespaceString, System.StringComparison.Ordinal))
							baseSerializerClassName = (baseNamespaceString + "." + baseSerializerClassName);
					}
				}
			}
		}
	}

	if(!string.IsNullOrEmpty(namespaceString))
	{
#>
namespace <#= namespaceString #>
{
<#+
		PushIndent("\t");
	}
	bool isRootClass = BaseClassHelper.Instance.IsRootClass (domainClass);
	int inheritanceDepth = CodeGenerationUtilities.CalculateInheritanceDepth (domainClass);
#>
/// <summary>
/// Serializer <#= serializerGenerationClassName #> for DomainClass <#= domainClass.GetRelativeName(namespaceString, false) #>.
/// </summary>
<#+
	if (domainClass.GeneratesDoubleDerived)
	{
		if (inheritanceDepth > 6)
		{
#>
[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1501:AvoidExcessiveInheritance", Justification = "Generated code.")]
<#+
		}
	}
	else if (inheritanceDepth > 5)
	{
#>
[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1501:AvoidExcessiveInheritance", Justification = "Generated code.")]
<#+
	}
#>
<#= CodeGenerationUtilities.GetTypeAccessModifier(domainClass.AccessModifier) #><#= domainClass.GeneratesDoubleDerived ? " abstract" : (domainClass.InheritanceModifier == InheritanceModifier.Sealed ? " sealed" : string.Empty) #> partial class <#= serializerGenerationClassName #> : <#= baseSerializerClassName #>
{
<#+
	// Properties of this domain class that will be serialized as XML attributes.
	int calculatedAttribPropCount;
	List<DomainProperty> attribProps = CodeGenerationUtilities.GetAttributeProperties (domainClass, out calculatedAttribPropCount);
	bool generateAttributePropertiesReadMethods = false;
	bool generateAttributePropertiesWriteMethods = false;
	// Sort the properties if necessary. Also note that because the local variable "attribProps" here is used by both ReadPropertiesFromAttributes() and 
	// WritePropertiesAsAttributes(), sorting it here will affect both methods at the same time.
	CodeGenerationUtilities.SortProperties (attribProps);
	
	// Properties of this domain class that will be serialized as nested XML elements.
	int calculatedElementPropCount;
	List<DomainProperty> elementProps = CodeGenerationUtilities.GetElementProperties (domainClass, out calculatedElementPropCount);
	bool generateElementPropertiesReadMethods = false;
	bool generateElementPropertiesWriteMethods = false;
	// Sort the properties by order (if specified).
	// Note that because the local variable "elementProps" here is used by both ReadPropertiesFromElements() and 
	// WritePropertiesAsElements(), sorting it here will affect both methods at the same time.
	CodeGenerationUtilities.SortProperties (elementProps);
	
	// All relationships that will be serialized inside this class	
	List<DomainRole> roles = GetSerializedRelationships (domainClass);
	bool generateChildElementsMethods = false;
	bool generateElementsMethods = false;
	// Note, similar as the local variable "elementProps" used above, the "roles" here will be used in generating
	// both ReadElements() and WriteElements().
	CodeGenerationUtilities.SortRoles (roles);

	// XmlCustom attribute
	bool isCustom = false;
	if(domainClass.ClassData!=null)
	{
		isCustom = domainClass.ClassData.IsCustom;
	}
	
	// See if this class can be serialized as moniker. If so, generate helper methods for that.
	MonikerData monikerDataDC = MonikerDataCache[domainClass];
	bool generateMonikerHelpers = false;
	if( monikerDataDC.CanBeMonikerized )
	{
		generateMonikerHelpers = true;
	}
#>
	#region Constructor
	/// <summary>
	/// <#= serializerGenerationClassName #> Constructor
	/// </summary>
	<#= domainClass.GeneratesDoubleDerived ? "protected" : "public" #> <#= serializerGenerationClassName #> ()
		: base ()
	{
<#+
	if (isCustom)
	{
#>
		// IsCustom == true, calling CustomConstruction().
		// Provide your custom constructor implementation with following signature:
		//   private void CustomConstructor();
		// You can call DefaultConstructor() for the default implementation.
		this.CustomConstructor();
	}
	
	/// <summary>
	/// Default implementation of constructor, which does nothing.
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMethodsAsStatic", Justification = "Matching the signature of constructor.")]
	private void DefaultConstructor()
	{	// Do nothing.
<#+
	}
#>
	}
	#endregion

<#+

	this.GenerateResetMethod(isSealed);


	if ((monikerizationSupportOnly && !readSupportOnly) || isAbstract)
	{
#>
	#region Public Properties
	/// <summary>
	/// Cannot be serialized.
	/// </summary>
	public override string XmlTagName
	{
		[global::System.Diagnostics.DebuggerStepThrough]
		get { return string.Empty; }
	}

	/// <summary>
	/// Cannot be monikerized.
	/// </summary>
	public override string MonikerTagName
	{
		[global::System.Diagnostics.DebuggerStepThrough]
		get { return string.Empty; }
	}
	
	/// <summary>
	/// Cannot be monikerized.
	/// </summary>
	public override string MonikerAttributeName
	{
		[global::System.Diagnostics.DebuggerStepThrough]
		get { return string.Empty; }
	}
	#endregion

<#+
	}
	else
	{
#>
	#region Public Properties
	/// <summary>
	/// This is the XML tag name used to serialize an instance of <#= domainClass.Name #>.
	/// </summary>
	public override string XmlTagName
	{
<#+
		if (isCustom)
		{
#>
		get 
		{	// IsCustom == true, calling CustomXmlTagName.
			// Provide your custom implementation with following signature:
			//   private string CustomXmlTagName { get; }
			// You can call DefaultXmlTagName for the default implementation.
			return this.CustomXmlTagName;
		}
	}
	
	/// <summary>
	/// Default implementation of XmlTagName.
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMethodsAsStatic", Justification = "Matching the signature of CustomXmlTagName.")]
	private string DefaultXmlTagName
	{
<#+
		}
#>
		[global::System.Diagnostics.DebuggerStepThrough]
		get { return @"<#= CodeGenerationUtilities.GetDomainClassXmlTagName (domainClass, currentXmlNamespace) #>"; }
	}
<#+
		if (generateMonikerHelpers)
		{
#>

	/// <summary>
	/// This is the XML tag name used to serialize a monikerized instance of <#= domainClass.Name #>.
	/// </summary>
	public override string MonikerTagName
	{
<#+
			if (isCustom)
			{
#>
		get 
		{	// IsCustom == true, calling CustomMonikerTagName.
			// Provide your custom implementation with following signature:
			//   private string CustomMonikerTagName { get; }
			// You can call DefaultMonikerTagName for the default implementation.
			return this.CustomMonikerTagName;
		}
	}
	
	/// <summary>
	/// Default implementation of MonikerTagName.
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMethodsAsStatic", Justification = "Matching the signature of CustomMonikerTagName.")]
	private string DefaultMonikerTagName
	{
<#+
			}
#>
		[global::System.Diagnostics.DebuggerStepThrough]
		get { return @"<#= CodeGenerationUtilities.GetDomainClassMonikerTagName (domainClass, currentXmlNamespace) #>"; }
	}
	
	/// <summary>
	/// This is the name of the XML attribute that stores the moniker of <#= domainClass.Name #> in a serialized monikerized instance.
	/// </summary>
	public override string MonikerAttributeName
	{
<#+
			if (isCustom)
			{
#>
		get 
		{	// IsCustom == true, calling CustomMonikerAttributeName.
			// Provide your custom implementation with following signature:
			//   private string CustomMonikerAttributeName { get; }
			// You can call DefaultMonikerAttributeName for the default implementation.
			return this.CustomMonikerAttributeName;
		}
	}
	
	/// <summary>
	/// Default implementation of MonikerAttributeName.
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMethodsAsStatic", Justification = "Matching the signature of CustomMonikerAttributeName.")]
	private string DefaultMonikerAttributeName
	{
<#+
			}
#>
		[global::System.Diagnostics.DebuggerStepThrough]
		get { return @"<#= monikerDataDC.MonikerXmlAttribute #>"; }
	}
<#+
		}
		else
		{
#>

	/// <summary>
	/// Cannot be monikerized.
	/// </summary>
	public override string MonikerTagName
	{
		[global::System.Diagnostics.DebuggerStepThrough]
		get { return string.Empty; }
	}
	
	/// <summary>
	/// Cannot be monikerized.
	/// </summary>
	public override string MonikerAttributeName
	{
		[global::System.Diagnostics.DebuggerStepThrough]
		get { return string.Empty; }
	}
<#+
		}
#>
	#endregion

<#+
	}

	bool generateReadTargetRolePlayer = false;	// True if the domainClass is a relationship and defines a new target role player.
	if (monikerizationSupportOnly && !readSupportOnly)
	{
#>
	#region Not-supported Base Methods
	/// <summary>
	/// Not Supported.
	/// </summary>
	public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	{
		throw new global::System.NotSupportedException();
	}

<#+
	}
	else if (isAbstract)
	{
#>
	#region Read Methods
	/// <summary>
	/// <#= domainClass.Name #> is abstract and cannot be instantiated, so this method throws NotSupportedException.
	/// </summary>
	/// <remarks>
	/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	/// of the <#= domainClass.Name #> element that is about to be deserialized. 
	/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	/// or the close tag of the parent element (or EOF).
	/// </remarks>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="element">In-memory <#= domainClass.Name #> instance that will get the deserialized data.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
	public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	{
		throw new global::System.NotSupportedException();
	}
<#+

		// Determine whether we need to generate methods for ReadAttributes() and/or ReadElements().
		if (isRootClass)
		{
			generateAttributePropertiesReadMethods = true;
			generateAttributePropertiesWriteMethods = true;
			if (isRelationship)
				generateReadTargetRolePlayer = true;
		}
		else if (attribProps.Count > calculatedAttribPropCount)
		{
			generateAttributePropertiesReadMethods = true;
			generateAttributePropertiesWriteMethods = true;
		}
		else if (attribProps.Count > 0)
		{	// No need to generate read method because all properties are calculated (read-only).
			generateAttributePropertiesWriteMethods = true;
		}
		
		if (elementProps.Count > 0 || roles.Count > 0)
		{
			generateElementsMethods = true;
		}
	}
	else
	{
#>
	#region Read Methods
	/// <summary>
	/// Public Read() method that deserializes one <#= domainClass.Name #> instance from XML.
	/// </summary>
	/// <remarks>
	/// When this method is called, caller guarantees that the passed-in XML reader is positioned at the open XML tag
	/// of the <#= domainClass.Name #> element that is about to be deserialized. 
	/// The method needs to ensure that when it returns, the reader is positioned at the open XML tag of the next sibling element,
	/// or the close tag of the parent element (or EOF).
	/// </remarks>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="element">In-memory <#= domainClass.Name #> instance that will get the deserialized data.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
	public override void Read(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	{
<#+
		if (isCustom)
		{
#>
		// IsCustom == true, calling CustomRead().
		// Provide your custom implementation with following signature:
		//   private void CustomRead(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader);
		// You can call DefaultRead() for the default implementation.
		this.CustomRead(serializationContext, element, reader);
	}
	
	/// <summary>
	/// Default implementation of Read().
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	private void DefaultRead(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	{
<#+
		}
#>
		#region Check Parameters
		global::System.Diagnostics.Debug.Assert (serializationContext != null);
		if (serializationContext == null)
			throw new global::System.ArgumentNullException ("serializationContext");
		global::System.Diagnostics.Debug.Assert (element != null);
		if (element == null)
			throw new global::System.ArgumentNullException ("element");
		global::System.Diagnostics.Debug.Assert (reader != null);
		if (reader == null)
			throw new global::System.ArgumentNullException ("reader");
		#endregion
		
<#+
		if (attribProps.Count == calculatedAttribPropCount) // No non-calculated properties
		{
			if (isRootClass)
			{
				if (!isSealed)
				{	// Even though this class has no properties deserialized from XML attributes by itself, derived
					// classes can still define some, so need to generate a virtual stub.
					generateAttributePropertiesReadMethods = true;
					generateAttributePropertiesWriteMethods = true;
#>
		// Read properties serialized as XML attributes.
		ReadPropertiesFromAttributes(serializationContext, element, reader);
			
<#+
				}
				else
				{	// This is a root class and it is sealed, so there's no need to generate anything for read.
					if (calculatedAttribPropCount > 0)
						generateAttributePropertiesWriteMethods = true; // Still need to serialized the calculated properties.
				}
			}
			else
			{	// This class doesn't define any properties that needs to be deserialized from XML attributes, so 
				// only need to call base class.
#>
		// Read properties serialized as XML attributes.
		base.ReadPropertiesFromAttributes(serializationContext, element, reader);

<#+
				if (calculatedAttribPropCount > 0)
					generateAttributePropertiesWriteMethods = true; // Still need to serialized the calculated properties.
			}
		}
		else
		{	// Read properties serialized as XML attributes.
			generateAttributePropertiesReadMethods = true;
			generateAttributePropertiesWriteMethods = true;
#>
		// Read properties serialized as XML attributes.
		ReadPropertiesFromAttributes(serializationContext, element, reader);

<#+
		}
		
		if (elementProps.Count == 0 && roles.Count == 0 && isRootClass && isSealed)
		{	// This class is root and sealed, which means it can't contain any nested XML elements in it, so skip
			// the whole XML element if it's not a relationship, read only the non-anchor role-player otherwise.
			if (isRelationship)
			{
				bool isEmbedding = ((DomainRelationship)domainClass).IsEmbedding;
				DomainRole targetRole = (domainClass as DomainRelationship).Target;
				generateReadTargetRolePlayer = true;
#>
		// Read target role-player.
		if (!serializationContext.Result.Failed)
		{
			if (!reader.IsEmptyElement)
			{
				// Read to the start of the first child element.
				DslModeling::SerializationUtilities.SkipToFirstChild(reader);
					
				// Read any extension element data under this XML element
				<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);

				// Read target role-player <#= targetRole.Name #>.
				ReadTargetRolePlayer(serializationContext, element, reader);

				// Skip all nested child elements.
				while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				{
					// Encountered one unknown XML element, skip it and keep reading.
					<#= behavior.Name #>SerializationMessages.UnexpectedXmlElement(serializationContext, reader);
					DslModeling::SerializationUtilities.Skip(reader);
				}
			}
			else
			{
				<#= behavior.Name #>SerializationMessages.DanglingRelationship(serializationContext, reader, <#= CodeGenerationUtilities.WrapAsCSharpString(domainClass.Name) #>);
			}
		}

		// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
		DslModeling::SerializationUtilities.Skip(reader);
<#+
			}
			else
			{
#>
		// Skip over this element and its children
		if ( !reader.IsEmptyElement )
		{
			bool reportInvalidFirstChildError = false;
			// advance to its first children
			DslModeling::SerializationUtilities.SkipToFirstChild(reader);
			while (!reader.EOF && reader.NodeType != global::System.Xml.XmlNodeType.EndElement)
			{
				if (!reportInvalidFirstChildError)
				{
					reportInvalidFirstChildError = true;
					<#= behavior.Name #>SerializationMessages.UnexpectedXmlElement(serializationContext, reader);
				}
				// skip the rest of the children if there's any.
				DslModeling::SerializationUtilities.Skip(reader);
			}
		}

		DslModeling::SerializationUtilities.Skip(reader);
<#+
			}
		}
		else
		{
			DomainRole targetRole = null;
			if (isRelationship)
			{
				targetRole = (domainClass as DomainRelationship).Target;
				if (((DomainRelationship)domainClass).IsEmbedding)
				{
#>
		// Read nested XML elements, which include at least the instance of target role-player <#= targetRole.Name #>
<#+
				}
				else
				{
#>
		// Read nested XML elements, which include at least the monikerized instance of target role-player <#= targetRole.Name #>
<#+
				}
			}
			else
			{
#>
		// Read nested XML elements.
<#+
			}
#>
		if (!serializationContext.Result.Failed)
		{
			if (!reader.IsEmptyElement)
			{
				// Read to the start of the first child element.
				DslModeling::SerializationUtilities.SkipToFirstChild(reader);
				
				// Read any extension element data under this XML element
				<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.ReadExtensions(serializationContext, element, reader);
				
<#+
			if (isRelationship)
			{
				if (CodeGenerationUtilities.DefinesNewTargetRole (domainClass as DomainRelationship))
				{	// This relationship defined a new target role player, read it.
					generateReadTargetRolePlayer = true;
#>
				// Read target role-player <#= targetRole.Name #>.
				ReadTargetRolePlayer(serializationContext, element, reader);

<#+
				}
				else
				{	// Call base implementation to read the target role.
#>
				// Read target role-player <#= targetRole.Name #>.
				base.ReadTargetRolePlayer(serializationContext, element, reader);

<#+
				}
			}
#>
				// Read nested XML elements, they can be either properties serialized as XML elements, or child 
				// model elements.
				while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
				{
<#+
			if (elementProps.Count == 0 && roles.Count == 0 && !isRootClass && !domainClass.GeneratesDoubleDerived)
			{	// This class doesn't define anything that can appear as nested XML elements, so only need to 
				// call base class implementation directly.
#>
					base.ReadElements(serializationContext, element, reader);
<#+
			}
			else
			{
				generateElementsMethods = true;
#>
					ReadElements(serializationContext, element, reader);
<#+
			}
#>
					if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
					{
						// Encountered one unknown XML element, skip it and keep reading.
						<#= behavior.Name #>SerializationMessages.UnexpectedXmlElement(serializationContext, reader);
						DslModeling::SerializationUtilities.Skip(reader);
					}
				}
			}
<#+
			if (isRelationship)
			{
#>
			else
			{
				<#= behavior.Name #>SerializationMessages.DanglingRelationship(serializationContext, reader, <#= CodeGenerationUtilities.WrapAsCSharpString(domainClass.Name) #>);
			}
<#+
			}
#>
		}

		// Advance the reader to the next element (open tag of the next sibling, end tag of the parent, or EOF)
		DslModeling::SerializationUtilities.Skip(reader);
<#+
		}
#>
	}
	
<#+
	}
	
	if (generateReadTargetRolePlayer)
	{
		bool isEmbedding = ((DomainRelationship)domainClass).IsEmbedding;
		DomainRole targetRole = (domainClass as DomainRelationship).Target;
		DomainClass targetRolePlayer = targetRole.RolePlayer;
		string targetRoleType = targetRolePlayer.GetRelativeName(namespaceString, true);
#>

	/// <summary>
	/// This method reads the target role player <#= targetRole.Name #>.
	/// </summary>
	/// <remarks>
	/// The caller will guarantee that the reader is positioned at the open tag of the first child XML element.
	/// This method will read only one target role player instance. The method will skip any child XML element it encounters until it reaches:
	/// 1) The open tag of the target role player.
	/// 2) The end tag of the parent element (dangling relationship).
	/// 3) EOF (dangling relationship).
	/// After the call, the reader is positioned at:
	/// 1) The open tag of the next child element after the target role player.
	/// 2) The end tag of the parent element.
	/// 3) EOF.
	/// </remarks>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="element">In-memory <#= domainClass.Name #> instance that will link to the target <#= targetRolePlayer.Name #> instance.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
	<#= (isSealed && isRootClass) ? "private static" : "protected" #> <#= isRootClass ? (isSealed ? string.Empty : "virtual ") : "override " #>void ReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	{
<#+
		if (isCustom)
		{
#>
		// IsCustom == true, calling CustomReadTargetRolePlayer();
		// Provide your custom implementation with following signature:
		//   private <#= isSealed ? "static " : string.Empty #>void CustomReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader);
		// You can call DefaultReadTargetRolePlayer() for the default implementation.
		CustomReadTargetRolePlayer(serializationContext, element, reader);
	}
	
	/// <summary>
	/// Default implementation of ReadTargetRolePlayer().
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	private <#= isSealed ? "static " : string.Empty #>void DefaultReadTargetRolePlayer(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	{
<#+
		}
#>
		#region Check Parameters
		global::System.Diagnostics.Debug.Assert (serializationContext != null);
		if (serializationContext == null)
			throw new global::System.ArgumentNullException ("serializationContext");
		global::System.Diagnostics.Debug.Assert (element != null);
		if (element == null)
			throw new global::System.ArgumentNullException ("element");
		global::System.Diagnostics.Debug.Assert (reader != null);
		if (reader == null)
			throw new global::System.ArgumentNullException ("reader");
		#endregion

<#+
		string targetRoleInstanceName = string.Empty;
		if (isEmbedding)
		{
			targetRoleInstanceName = "targetRolePlayer";
#>
		// Read the instance of target role-player <#= targetRole.Name #>
		DslModeling::ModelElement <#= targetRoleInstanceName #> = null;
<#+
		}
		else
		{
			targetRoleInstanceName = "targetRoleMoniker";
#>
		// Read the monikerized instance of target role-player <#= targetRole.Name #>
		DslModeling::Moniker <#= targetRoleInstanceName #> = null;
<#+
		}
#>
		DslModeling::DomainClassXmlSerializer targetRoleSerializer = serializationContext.Directory.GetSerializer(<#= targetRoleType #>.DomainClassId);
		global::System.Diagnostics.Debug.Assert(targetRoleSerializer != null, "Cannot find serializer for <#= targetRolePlayer.Name #>!");

		while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
		{
<#+
		// If target end is a mel, read it directly. Otherwise read the moniker.
		if (isEmbedding)
		{
#>
			<#= targetRoleInstanceName #> = targetRoleSerializer.TryCreateInstance(serializationContext, reader, element.Partition);
			if (<#= targetRoleInstanceName #> != null)
			{
				// Attach the target role-player.
				DslModeling::DomainRoleInfo.SetRolePlayer(element as DslModeling::ElementLink, <#= classTypeString #>.<#= targetRole.Name #>DomainRoleId, <#= targetRoleInstanceName #>);
				// Read target role-player.
				DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (<#= targetRoleInstanceName #>.GetDomainClass().Id);	
				global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + <#= targetRoleInstanceName #>.GetDomainClass().Name + "!");
				targetSerializer.Read(serializationContext, <#= targetRoleInstanceName #>, reader);
				break;
			}
<#+
		}
		else
		{
#>
			<#= targetRoleInstanceName #> = targetRoleSerializer.TryCreateMonikerInstance(serializationContext, reader, ((<#= classTypeString #>)element).<#= targetRole.Opposite.Name #>, <#= classTypeString #>.DomainClassId, element.Partition);
			if (<#= targetRoleInstanceName #> != null)
			{
				// Attach the target role-player moniker.
				DslModeling::DomainRoleInfo.SetRolePlayerMoniker (element as DslModeling::ElementLink, <#= classTypeString #>.<#= targetRole.Name #>DomainRoleId, <#= targetRoleInstanceName #>);
				// Moniker tag has no child XML elements in it, so just skip to the next element.
				DslModeling::SerializationUtilities.Skip(reader);
				break;
			}
<#+					
		}
#>
			// Encountered one unknown XML element, skip it and keep reading.
			<#= behavior.Name #>SerializationMessages.UnexpectedXmlElement(serializationContext, reader);
			DslModeling::SerializationUtilities.Skip(reader);
		}
		if (<#= targetRoleInstanceName #> == null)
		{
			<#= behavior.Name #>SerializationMessages.DanglingRelationship(serializationContext, reader, <#= CodeGenerationUtilities.WrapAsCSharpString(domainClass.Name) #>);
		}
	}
<#+
	}
	
	if (generateAttributePropertiesReadMethods)
	{
#>

	/// <summary>
	/// This method deserializes all properties that are serialized as XML attributes.
	/// </summary>
	/// <remarks>
	/// Because this method only handles properties serialized as XML attributes, the passed-in reader shouldn't be moved inside this method.
	/// The caller will guarantee that the reader is positioned on the open XML tag of the current element being deserialized.
	/// </remarks>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="element">In-memory <#= domainClass.Name #> instance that will get the deserialized data.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
<#+
		if (isCustom)
		{	
			// This gen'ed might not be used. It only be used if user invokes the DefaultRead
#>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]

<#+
		}
		else
		{
#>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
<#+
		}
#>
	protected override void ReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	{
<#+
		if (isCustom)
		{
#>
		// IsCustom == true, calling CustomReadPropertiesFromAttributes();
		// Provide your custom implementation with following signature:
		//   private void CustomReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader);
		// You can call DefaultReadPropertiesFromAttributes() for the default implementation.
		CustomReadPropertiesFromAttributes(serializationContext, element, reader);
	}
	
	/// <summary>
	/// Default implementation of ReadPropertiesFromAttributes().
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	private void DefaultReadPropertiesFromAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	{
<#+
		}
		
#>
		// Always call the base class so any extensions are deserialized
		base.ReadPropertiesFromAttributes(serializationContext, element, reader);

<#+
		
		if (attribProps.Count == calculatedAttribPropCount)
		{
#>
		// There is no property to read; do nothing
<#+
		}
		else
		{
			string instanceName = "instanceOf" + domainClass.Name.TrimStart('@');
#>
		<#= classTypeString #> <#= instanceName #> = element as <#= classTypeString #>;
		global::System.Diagnostics.Debug.Assert(<#= instanceName #> != null, "Expecting an instance of <#= domainClass.Name #>");

<#+
			foreach(DomainProperty attribProp in attribProps)
			{
				if (attribProp.Kind == PropertyKind.Calculated)
					continue; // Ignore calculated properties, as they're read-only.
				string attribInstanceName = "attrib" + attribProp.Name.TrimStart('@');
				string attribTagName = CodeGenerationUtilities.GetPropertyTagName (attribProp);
				string propertyType = attribProp.Type.GetRelativeName(namespaceString, true);
#>
		// <#= attribProp.Name #>
		if (!serializationContext.Result.Failed)
		{
			string <#= attribInstanceName #> = <#= behavior.DslLibrary.Name #>SerializationHelper.Instance.ReadAttribute(serializationContext, element, reader, "<#= attribTagName #>");
			if (<#= attribInstanceName #> != null)
			{
				<#= propertyType #> valueOf<#= attribProp.Name.TrimStart('@') #>;
				if (DslModeling::SerializationUtilities.TryGetValue<<#= propertyType #>>(serializationContext, <#= attribInstanceName #>, out valueOf<#= attribProp.Name.TrimStart('@') #>))
				{
<#+
				if (attribProp.SetterAccessModifier == AccessModifier.Public)
				{
#>
					<#= instanceName #>.<#= attribProp.Name #> = valueOf<#= attribProp.Name.TrimStart('@') #>;
<#+
				}
				else
				{
#>
					// Non-public setter, use DomainPropertyInfo method.
					DslModeling::DomainPropertyInfo propInfo = <#= instanceName #>.Partition.DomainDataDirectory.GetDomainProperty (<#= classTypeString #>.<#= attribProp.Name #>DomainPropertyId);
					global::System.Diagnostics.Debug.Assert (propInfo != null, "Cannot get DomainPropertyInfo for <#= classTypeString #>.<#= attribProp.Name #>!");
					propInfo.SetValue(<#= instanceName #>, valueOf<#= attribProp.Name.TrimStart('@') #>);
<#+
				}
#>
				}
				else
				{	// Invalid property value, ignored.
					<#= behavior.Name #>SerializationMessages.IgnoredPropertyValue(serializationContext, reader, "<#= attribTagName #>", typeof(<#= propertyType #>), <#= attribInstanceName #>);
				}
			}
		}
<#+
			}
		}
#>
	}
<#+
	}

	if (generateElementsMethods)
	{
	
#>

	/// <summary>
	/// This methods deserializes nested XML elements inside the passed-in element.
	/// </summary>
	/// <remarks>
	/// The caller will guarantee that the current element does have nested XML elements, and the call will position the 
	/// reader at the open tag of the first child XML element.
	/// This method will read as many child XML elements as it can. It returns under three circumstances:
	/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the open 
	///    tag of the unknown element. This implies that if the first child XML element is unknown, this method should return 
	///    immediately and do nothing.
	/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	/// 3) EOF.
	/// </remarks>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="element">In-memory <#= domainClass.Name #> instance that will get the deserialized data.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
<#+
		if (isCustom)
		{
#>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
<#+
		}
#>
	protected override void ReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	{
<#+
		if (isCustom)
		{
#>
		// IsCustom == true, calling CustomReadElements();
		// Provide your custom implementation with following signature:
		//   private void CustomReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader);
		// You can call DefaultReadElements() for the default implementation.
		CustomReadElements(serializationContext, element, reader);
	}

	/// <summary>
	/// Default implementation of ReadElements().
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	private void DefaultReadElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlReader reader)
	{
<#+
		}

#>
		// Always call the base class so any extensions are deserialized
		base.ReadElements(serializationContext, element, reader);

<#+

		string instanceName = "instanceOf" + domainClass.Name.TrimStart('@');
		if (elementProps.Count > 0 || roles.Count > 0)
		{
#>
		<#= classTypeString #> <#= instanceName #> = element as <#= classTypeString #>;
		global::System.Diagnostics.Debug.Assert(<#= instanceName #> != null, "Expecting an instance of <#= domainClass.Name #>!");

<#+
		}
		if (elementProps.Count > 0)
		{
			generateElementPropertiesReadMethods = true;
			generateElementPropertiesWriteMethods = true;
#>
		// Read properties serialized as nested XML elements.
		if (!serializationContext.Result.Failed)
			ReadPropertiesFromElements(serializationContext, <#= instanceName #>, reader);
<#+
		}
		if (roles.Count > 0)
		{
			generateChildElementsMethods = true;
#>
		// Read child model elements (which are always serialized as nested XML elements).
		if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
			ReadChildElements(serializationContext, <#= instanceName #>, reader);
<#+
		}
#>
	}
<#+
	}

	if (generateElementPropertiesReadMethods)
	{
#>

	/// <summary>
	/// This method deserializes all properties that are serialized as nested XML elements.
	/// </summary>
	/// <remarks>
	/// The caller will position the reader at the open tag of the first child XML element, but it can be either a property 
	/// or a child element. 
	/// This method will read as many properties as it can. It returns under three circumstances:
	/// 1) When an unknown child XML element is encountered ("unknown" means it's not a property. It can be either a bogus tag, or
	///    a child model element). In this case, this method will position the reader at the open tag of the unknown element. This
	///    implies the if the first child XML element is unknown, this method should return immediately and do nothing.
	/// 2) When all properties are read. In this case, the reader will be positioned at the next tag, which is either the open tag
	///    of the next sibling (which can be the open tag of a child model element), or the end tag of the parent element.
	/// 3) EOF.
	/// </remarks>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="element">In-memory <#= domainClass.Name #> instance that will get the deserialized data.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
<#+
		if (isCustom)
		{
#>		
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
<#+
		}
		else
		{
#>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
<#+
		}
#>
	private static void ReadPropertiesFromElements(DslModeling::SerializationContext serializationContext, <#= classTypeString #> element, global::System.Xml.XmlReader reader)
	{
<#+
		if (isCustom)
		{
#>
		// IsCustom == true, calling CustomReadPropertiesFromElements();
		// Provide your custom implementation with following signature:
		//   private static void CustomReadPropertiesFromElements(DslModeling::SerializationContext serializationContext, <#= classTypeString #> element, global::System.Xml.XmlReader reader)
		// You can call DefaultReadPropertiesFromElements() for the default implementation.
		CustomReadPropertiesFromElements(serializationContext, element, reader);
	}
	
	/// <summary>
	/// Default implementation of DefaultReadPropertiesFromElements().
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	private static void DefaultReadPropertiesFromElements(DslModeling::SerializationContext serializationContext, <#= classTypeString #> element, global::System.Xml.XmlReader reader)
	{
<#+
		}
#>
		while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
		{
			switch (reader.LocalName)
			{
<#+
		foreach(DomainProperty elementProp in elementProps)
		{
			string strValueName = "str" + elementProp.Name.TrimStart('@');
			string propertyType = elementProp.Type.GetRelativeName(namespaceString, true);
#>
				case "<#= CodeGenerationUtilities.GetPropertyTagName (elementProp) #>":	// <#= elementProp.Name #>
<#+
			if (elementProp.Kind == PropertyKind.Calculated)
			{
#>
					// Calculated properties are saved, but not read back, so ignore.
					DslModeling::SerializationUtilities.Skip(reader);  // Skip this tag.
<#+
			}
			else
			{
#>
					if (reader.IsEmptyElement)
					{	// No serialized value, must be default one.
						DslModeling::SerializationUtilities.Skip(reader);  // Skip this tag.
					}
					else
					{
						string <#= strValueName #> = <#= behavior.DslLibrary.Name #>SerializationHelper.Instance.ReadElementContentAsString(serializationContext, element, reader);
						<#= propertyType #> valueOf<#= elementProp.Name.TrimStart('@') #>;
						if (DslModeling::SerializationUtilities.TryGetValue<<#= propertyType #>>(serializationContext, <#= strValueName #>, out valueOf<#= elementProp.Name.TrimStart('@') #>))
						{
<#+
				if (elementProp.SetterAccessModifier == AccessModifier.Public)
				{
#>
							element.<#= elementProp.Name #> = valueOf<#= elementProp.Name.TrimStart('@') #>;
<#+
				}
				else
				{
#>
							// Non-public setter, use DomainPropertyInfo method.
							DslModeling::DomainPropertyInfo propInfo = element.Partition.DomainDataDirectory.GetDomainProperty (<#= classTypeString #>.<#= elementProp.Name #>DomainPropertyId);
							global::System.Diagnostics.Debug.Assert (propInfo != null, "Cannot get DomainPropertyInfo for <#= classTypeString #>.<#= elementProp.Name #>!");
							propInfo.SetValue(element, valueOf<#= elementProp.Name.TrimStart('@') #>);
<#+
				}
#>
						}
						else
						{	// Invalid property value, ignored.
							<#= behavior.Name #>SerializationMessages.IgnoredPropertyValue(serializationContext, reader, "<#= CodeGenerationUtilities.GetPropertyTagName (elementProp) #>", typeof(<#= propertyType #>), <#= strValueName #>);
						}

						DslModeling::SerializationUtilities.SkipToNextElement(reader);
					}
<#+
			}
#>
					break;
<#+
		}
#>
				default:
					return;  // Don't know this element.
			}
		}
	}
<#+
	}




	if (generateChildElementsMethods)
	{
		List<DomainRole> nonOmittedRoles = new List<DomainRole> ();
		List<DomainRole> omittedRoles = new List<DomainRole> ();
		foreach (DomainRole role in roles)
		{
			DomainRelationship rel = role.Relationship;
			if (CodeGenerationUtilities.OmitElement(rel))
				omittedRoles.Add (role);
			else
				nonOmittedRoles.Add (role);
		}
#>

	/// <summary>
	/// This method deserializes all child model elements.
	/// </summary>
	/// <remarks>
	/// The caller will position the reader at the open tag of the first child XML element to deserialized.
	/// This method will read as many child elements as it can. It returns under three circumstances:
	/// 1) When an unknown child XML element is encountered. In this case, this method will position the reader at the 
	///    open tag of the unknown element. This implies that if the first child XML element is unknown, this method 
	///    should return immediately and do nothing.
	/// 2) When all child XML elemnets are read. In this case, the reader will be positioned at the end tag of the parent element.
	/// 3) EOF.
	/// </remarks>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
	/// <param name="element">In-memory <#= domainClass.Name #> instance that will get the deserialized data.</param>
<#+
		// Go through all the omitted roles to see if any of them needs SuppressMessage attribute.
		// We sometimes create relationship by calling its constructor directly, which will link up the two role-players. So calling the constructor
		// will do all the work and the result doesn't need to be assigned to anything.
		foreach (DomainRole omittedRole in omittedRoles)
		{
			DomainRelationship rel = omittedRole.Relationship;
			if (!CodeGenerationUtilities.UseFullForm(rel))
			{
				if (!rel.IsEmbedding || !omittedRole.IsPropertyGenerator)
				{
#>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806:DoNotIgnoreMethodResults", MessageId="<#= rel.GetFullName(false) #>", Justification = "Creating a relationship has the side-effect of connecting up the role-players.")]
<#+
				}
			}
		}
#>
	private static void ReadChildElements(DslModeling::SerializationContext serializationContext, <#= classTypeString #> element, global::System.Xml.XmlReader reader)
	{
<#+
		// If there's only one role, and it's not omit-element or its multiplicity is one, we don't need to generate a while loop to go through all possibilities;
		// we'll generate an if-statement in this case for cleaner generated code.
		bool useWhileLoop = ((roles.Count > 1) || (CodeGenerationUtilities.OmitElement (roles[0].Relationship) && CodeGenerationUtilities.AllowMultiple (roles[0])));
		if (useWhileLoop)
		{
#>
		while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
		{
<#+
			string indentation = string.Empty;
			if (nonOmittedRoles.Count == 0)
			{	// If all roles' relationships are omitted, there's no need to generate a switch-statement.
			}
			else 
			{	
				if (nonOmittedRoles.Count == 1)
				{	// Only one relationship not omitted, still no need to generate switch-statemnt.
					DomainRole role = nonOmittedRoles[0];
					DomainRelationship rel = role.Relationship;
					string relName = rel.Name;
					string relTagName = CodeGenerationUtilities.GetRelationshipTagName (role);
#>
			if (string.Compare(reader.LocalName, "<#= relTagName #>", global::System.StringComparison.CurrentCulture) == 0)
			{
				if (reader.IsEmptyElement)
				{	// No instance of this relationship, just skip
					DslModeling::SerializationUtilities.Skip(reader);
				}
				else
				{
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <<#= relTagName #>>
<#+
					if (CodeGenerationUtilities.AllowMultiple (role))
					{
#>
					Read<#= relName.TrimStart('@') #>Instances(serializationContext, element, reader);
<#+
					}
					else
					{
#>
					Read<#= relName.TrimStart('@') #>Instance(serializationContext, element, reader);
<#+
					}
#>
					DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </<#= relTagName #>>
				}
			}
			else
			{
<#+
					indentation = "\t";
				}
				else
				{	// Check all possiblilities.
#>
			switch (reader.LocalName)
			{
<#+
					foreach(DomainRole role in nonOmittedRoles)
					{
						DomainRelationship rel = role.Relationship;
						string relName = rel.Name;
						string relTagName = CodeGenerationUtilities.GetRelationshipTagName (role);
#>
				case "<#= relTagName #>":	// Relationship "<#= relName #>"
					if (reader.IsEmptyElement)
					{	// No instance of this relationship, just skip
						DslModeling::SerializationUtilities.Skip(reader);
					}
					else
					{
						DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <<#= relTagName #>>
<#+
						if (CodeGenerationUtilities.AllowMultiple (role))
						{
#>
						Read<#= relName.TrimStart('@') #>Instances(serializationContext, element, reader);
<#+
						}
						else
						{
#>
						Read<#= relName.TrimStart('@') #>Instance(serializationContext, element, reader);
<#+
						}
#>
						DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </<#= relTagName #>>
					}
					break;
<#+
					}
#>
				default:
<#+
					indentation = "\t\t";
				}
			}
			
			PushIndent (indentation);
			
			// Check for each omit-element relationships.
			foreach (DomainRole omittedRole in omittedRoles)
			{
				DomainRelationship rel = omittedRole.Relationship;
				string relName = rel.Name;
				string relType = rel.GetRelativeName(namespaceString, true);	
				DomainRole nonAnchorRole = omittedRole.Opposite;
				bool allowMultiple = CodeGenerationUtilities.AllowMultiple (omittedRole);
				string instanceName = string.Empty;
				string serializerName = string.Empty;
#>
			// Check if it's an instance of omit-element relationship "<#= relName #>"
<#+
				if (!allowMultiple)
				{	// Need to check if the link has already been created.
#>
			if (DslModeling::DomainRoleInfo.GetElementLinks<<#= relType #>> (element, <#= relType #>.<#= omittedRole.Name #>DomainRoleId).Count == 0)
			{
<#+
					PushIndent("\t");
				}
				
				if (CodeGenerationUtilities.UseFullForm (rel))
				{	// If a relationship is serialized in full-form, then we will read the tag for the relationship itself, instead of
					// the non-anchor role-player.
					instanceName = "new" + relName.TrimStart('@');
					serializerName = instanceName + "Serializer";
#>
			DslModeling::DomainClassXmlSerializer <#= serializerName #> = serializationContext.Directory.GetSerializer(<#= relType #>.DomainClassId);
			global::System.Diagnostics.Debug.Assert(<#= serializerName #> != null, "Cannot find serializer for <#= relType #>!");
			<#= relType #> <#= instanceName #> = <#= serializerName #>.TryCreateInstance (serializationContext, reader, element.Partition) as <#= relType #>;
			if (<#= instanceName #> != null)
			{
				DslModeling::DomainRoleInfo.SetRolePlayer (<#= instanceName #>, <#= relType #>.<#= omittedRole.Name #>DomainRoleId, element);
				DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (<#= instanceName #>.GetDomainClass().Id);	
				global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + <#= instanceName #>.GetDomainClass().Name + "!");
				targetSerializer.Read(serializationContext, <#= instanceName #>, reader);
				continue;
			}
<#+
					if (!allowMultiple)
					{	// Need to check if the link has already been created.
						PopIndent();
#>
			}
<#+
					}
#>

<#+
				}
				else
				{
					string nonAnchorRoleType = nonAnchorRole.RolePlayer.GetRelativeName(namespaceString, true);
					if (rel.IsEmbedding)
					{
						instanceName = "new" + nonAnchorRole.RolePlayer.Name.TrimStart('@') + "Of" + relName.TrimStart('@');
						serializerName = instanceName + "Serializer";
#>
			DslModeling::DomainClassXmlSerializer <#= serializerName #> = serializationContext.Directory.GetSerializer(<#= nonAnchorRoleType #>.DomainClassId);
			global::System.Diagnostics.Debug.Assert(<#= serializerName #> != null, "Cannot find serializer for <#= nonAnchorRole.RolePlayer.Name #>!");
			<#= nonAnchorRoleType #> <#= instanceName #> = <#= serializerName #>.TryCreateInstance(serializationContext, reader, element.Partition) as <#= nonAnchorRoleType #>;
			if (<#= instanceName #> != null)
			{
<#+
						if (omittedRole.IsPropertyGenerator && omittedRole.PropertySetterAccessModifier == AccessModifier.Public)
						{
							if (allowMultiple)
							{
#>
				element.<#= omittedRole.PropertyName #>.Add(<#= instanceName #>);
<#+
							}
							else
							{
#>
				element.<#= omittedRole.PropertyName #> = <#=  instanceName#>;
<#+
							}
						}
						else
						{	// Need to create the relationship instance explicitly.
#>
				new <#= relType #>(element.Partition, new DslModeling::RoleAssignment(<#= relType #>.<#= omittedRole.Name #>DomainRoleId, element), new DslModeling::RoleAssignment(<#= relType #>.<#= nonAnchorRole.Name #>DomainRoleId, <#= instanceName #>));
<#+
						}
#>
				DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (<#= instanceName #>.GetDomainClass().Id);	
				global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + <#= instanceName #>.GetDomainClass().Name + "!");
				targetSerializer.Read(serializationContext, <#= instanceName #>, reader);
				continue;
			}
<#+
					}
					else
					{
						instanceName = "new" + nonAnchorRole.RolePlayer.Name.TrimStart('@') + "MonikerOf" + relName.TrimStart('@');
						serializerName = instanceName + "Serializer";
#>
			DslModeling::DomainClassXmlSerializer <#= serializerName #> = serializationContext.Directory.GetSerializer(<#= nonAnchorRoleType #>.DomainClassId);
			global::System.Diagnostics.Debug.Assert(<#= serializerName #> != null, "Cannot find serializer for <#= nonAnchorRole.RolePlayer.Name #>!");
			DslModeling::Moniker <#= instanceName #> = <#= serializerName #>.TryCreateMonikerInstance(serializationContext, reader, element, <#= relType #>.DomainClassId, element.Partition);
			if (<#= instanceName #> != null)
			{
				new <#= relType #>(element.Partition, new DslModeling::RoleAssignment(<#= relType #>.<#= omittedRole.Name #>DomainRoleId, element), new DslModeling::RoleAssignment(<#= relType #>.<#= nonAnchorRole.Name #>DomainRoleId, <#= instanceName #>));
				DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
				continue;
			}
<#+
					}
					
					// If the relationship is not sealed, there can be relationships deriving it. All derived relationships will 
					// be serialized in full-form, so need to check if that's the case.
					if (rel.InheritanceModifier != InheritanceModifier.Sealed)
					{
						instanceName = "new" + relName.TrimStart('@');
						serializerName = instanceName + "Serializer";
#>
			else
			{
				DslModeling::DomainRelationshipXmlSerializer <#= serializerName #> = serializationContext.Directory.GetSerializer(<#= relType #>.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
				global::System.Diagnostics.Debug.Assert(<#= serializerName #> != null, "Cannot find serializer for <#= relType #>!");
				<#= relType #> <#= instanceName #> = <#= serializerName #>.TryCreateDerivedInstance (serializationContext, reader, element.Partition) as <#= relType #>;
				if (<#= instanceName #> != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (<#= instanceName #>, <#= relType #>.<#= omittedRole.Name #>DomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (<#= instanceName #>.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + <#= instanceName #>.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, <#= instanceName #>, reader);
					continue;
				}
			}
<#+
					}
					
					if (!allowMultiple)
					{	// Need to check if the link has already been created.
						PopIndent();
#>
			}
<#+
					}
#>

<#+
				}
			}
#>
			return;  // Don't know this element.
<#+
			PopIndent();
			if (nonOmittedRoles.Count > 0)
			{	// Close the else/switch clause.
#>
			}
<#+
			}
			
			// End of while-loop
#>
		}
<#+
		}
		else if (roles.Count == 1)
		{	// There's only one possiblity, so generate if-statement instead.
			DomainRole role = roles[0];
			DomainRelationship rel = role.Relationship;
			string relName = rel.Name;
			string relType = role.Relationship.GetRelativeName(namespaceString, true);				
			DomainRole nonAnchorRole = role.Opposite;
			bool allowMultiple = CodeGenerationUtilities.AllowMultiple (role);
			string instanceName = string.Empty;
			string serializerName = string.Empty;
#>
		if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
		{
<#+
			if (!CodeGenerationUtilities.OmitElement (rel))
			{
				string relTagName = CodeGenerationUtilities.GetRelationshipTagName (role);
#>
			if (string.Compare(reader.LocalName, "<#= relTagName #>", global::System.StringComparison.CurrentCulture) == 0)
			{
				if (reader.IsEmptyElement)
				{	// No instance of this relationship, just skip
					DslModeling::SerializationUtilities.Skip(reader);
				}
				else
				{
					DslModeling::SerializationUtilities.SkipToFirstChild(reader);  // Skip the open tag of <<#= relTagName #>>
<#+
					if (allowMultiple)
					{
#>
					Read<#= relName.TrimStart('@') #>Instances(serializationContext, element, reader);
<#+
					}
					else
					{
#>
					Read<#= relName.TrimStart('@') #>Instance(serializationContext, element, reader);
<#+
					}
#>
					DslModeling::SerializationUtilities.Skip(reader);  // Skip the close tag of </<#= relTagName #>>
				}
			}
<#+
			}
			else
			{	// Need to check if the link has already been created.
#>
			if (DslModeling::DomainRoleInfo.GetElementLinks<<#= relType #>> (element, <#= relType #>.<#= role.Name #>DomainRoleId).Count == 0)
			{
<#+
				if (CodeGenerationUtilities.UseFullForm (rel))
				{	// If a relationship is serialized in full-form, then we will read the tag for the relationship itself, instead of
					// the non-anchor role-player.
					instanceName = "new" + relName.TrimStart('@');
					serializerName = instanceName + "Serializer";
#>
				DslModeling::DomainClassXmlSerializer <#= serializerName #> = serializationContext.Directory.GetSerializer(<#= relType #>.DomainClassId);
				global::System.Diagnostics.Debug.Assert(<#= serializerName #> != null, "Cannot find serializer for <#= relType #>!");
				<#= relType #> <#= instanceName #> = <#= serializerName #>.TryCreateInstance (serializationContext, reader, element.Partition) as <#= relType #>;
				if (<#= instanceName #> != null)
				{
					DslModeling::DomainRoleInfo.SetRolePlayer (<#= instanceName #>, <#= relType #>.<#= role.Name #>DomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (<#= instanceName #>.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + <#= instanceName #>.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, <#= instanceName #>, reader);
				}
<#+
				}
				else
				{
					string nonAnchorRoleType = nonAnchorRole.RolePlayer.GetRelativeName(namespaceString, true);
					if (rel.IsEmbedding)
					{
						instanceName = "new" + nonAnchorRole.RolePlayer.Name.TrimStart('@') + "Of" + relName.TrimStart('@');
						serializerName = instanceName + "Serializer";
#>
				DslModeling::DomainClassXmlSerializer <#= serializerName #> = serializationContext.Directory.GetSerializer(<#= nonAnchorRoleType #>.DomainClassId);
				global::System.Diagnostics.Debug.Assert(<#= serializerName #> != null, "Cannot find serializer for <#= nonAnchorRole.RolePlayer.Name #>!");
				<#= nonAnchorRoleType #> <#= instanceName #> = <#= serializerName #>.TryCreateInstance(serializationContext, reader, element.Partition) as <#= nonAnchorRoleType #>;
				if (<#= instanceName #> != null)
				{
<#+
						if (role.IsPropertyGenerator)
						{
#>
					element.<#= role.PropertyName #> = <#= instanceName #>;
<#+
						}
						else
						{	// Need to create the relationship instance explicitly.
#>
					new <#= relType #>(element.Partition, new DslModeling::RoleAssignment(<#= relType #>.<#= role.Name #>DomainRoleId, element), new DslModeling::RoleAssignment(<#= relType #>.<#= nonAnchorRole.Name #>DomainRoleId, <#= instanceName #>));
<#+
						}
#>						
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (<#= instanceName #>.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + <#= instanceName #>.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, <#= instanceName #>, reader);
				}
<#+
					}
					else 
					{
						instanceName = "new" + nonAnchorRole.RolePlayer.Name.TrimStart('@') + "MonikerOf" + relName.TrimStart('@');
						serializerName = instanceName + "Serializer";
#>
				DslModeling::DomainClassXmlSerializer <#= serializerName #> = serializationContext.Directory.GetSerializer(<#= nonAnchorRoleType #>.DomainClassId);
				global::System.Diagnostics.Debug.Assert(<#= serializerName #> != null, "Cannot find serializer for <#= nonAnchorRole.RolePlayer.Name #>!");
				DslModeling::Moniker <#= instanceName #> = <#= serializerName #>.TryCreateMonikerInstance(serializationContext, reader, element, <#= relType #>.DomainClassId, element.Partition);
				if (<#= instanceName #> != null)
				{
					new <#= relType #>(element.Partition, new DslModeling::RoleAssignment(<#= relType #>.<#= role.Name #>DomainRoleId, element), new DslModeling::RoleAssignment(<#= relType #>.<#= nonAnchorRole.Name #>DomainRoleId, <#= instanceName #>));
					DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
				}
<#+
					}
					
					// If the relationship is not sealed, there can be relationships deriving it. All derived relationships will 
					// be serialized in full-form, so need to check if that's the case.
					if (rel.InheritanceModifier != InheritanceModifier.Sealed)
					{
						instanceName = "new" + relName.TrimStart('@');
						serializerName = instanceName + "Serializer";
#>
				else
				{
					DslModeling::DomainRelationshipXmlSerializer <#= serializerName #> = serializationContext.Directory.GetSerializer(<#= relType #>.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
					global::System.Diagnostics.Debug.Assert(<#= serializerName #> != null, "Cannot find serializer for <#= relType #>!");
					<#= relType #> <#= instanceName #> = <#= serializerName #>.TryCreateDerivedInstance (serializationContext, reader, element.Partition) as <#= relType #>;
					if (<#= instanceName #> != null)
					{
						DslModeling::DomainRoleInfo.SetRolePlayer (<#= instanceName #>, <#= relType #>.<#= role.Name #>DomainRoleId, element);
						DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (<#= instanceName #>.GetDomainClass().Id);	
						global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + <#= instanceName #>.GetDomainClass().Name + "!");
						targetSerializer.Read(serializationContext, <#= instanceName #>, reader);
					}
				}
<#+
					}
				}
#>
			}
<#+
			}
#>
		}
<#+
		}
#>
	}
<#+
		if (nonOmittedRoles.Count > 0)
		{	// Generate methods to read each relationship roles
			foreach(DomainRole role in nonOmittedRoles)
			{
				DomainRelationship rel = role.Relationship;
				string relName = rel.Name;
				string relType = role.Relationship.GetRelativeName(namespaceString, true);
				DomainRole childRole = role.Opposite;
				bool allowMultiple = CodeGenerationUtilities.AllowMultiple (role);
				string instanceName = string.Empty;
				string serializerName = string.Empty;
				bool suppressFxCopViolation = (!rel.IsEmbedding || !role.IsPropertyGenerator || role.PropertySetterAccessModifier != AccessModifier.Public);
				if (allowMultiple)
				{
#>

	/// <summary>
	/// Reads all instances of relationship <#= relName #>.
	/// </summary>
	/// <remarks>
	/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
	/// either the first instance, or a bogus tag. This method will deserialize all instances and ignore all bogus tags. When the
	/// method returns, the reader will be positioned at the end tag of the relationship (or EOF if somehow that happens).
	/// </remarks>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="element">In-memory <#= domainClass.Name #> instance that will get the deserialized data.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
<#+
					if (suppressFxCopViolation)
					{
#>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
<#+
					}
#>
	private static void Read<#= relName.TrimStart('@') #>Instances(DslModeling::SerializationContext serializationContext, <#= classTypeString #> element, global::System.Xml.XmlReader reader)
<#+
				}
				else
				{
#>

	/// <summary>
	/// Reads instance of relationship <#= relName #>.
	/// </summary>
	/// <remarks>
	/// The caller will position the reader at the open tag of the first XML element inside the relationship tag, so it can be
	/// either the first instance, or a bogus tag. This method will deserialize only the first valid instance and ignore all the
	/// rest tags (because the multiplicity allows only one instance). When the method returns, the reader will be positioned at 
	/// the end tag of the relationship (or EOF if somehow that happens).
	/// </remarks>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="element">In-memory <#= domainClass.Name #> instance that will get the deserialized data.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
<#+
					if (suppressFxCopViolation)
					{
#>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806")]
<#+
					}
#>
	private static void Read<#= relName.TrimStart('@') #>Instance(DslModeling::SerializationContext serializationContext, <#= classTypeString #> element, global::System.Xml.XmlReader reader)
<#+
				}
#>
	{
<#+
				if (!allowMultiple)
				{
#>
		if (DslModeling::DomainRoleInfo.GetElementLinks<<#= relType #>> (element, <#= relType #>.<#= role.Name #>DomainRoleId).Count > 0)
		{	// Only allow one instance, which already exists, so skip everything
			DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
			return;
		}

<#+
				}
#>
		while (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
		{
<#+
				string childRoleType = childRole.RolePlayer.GetRelativeName(namespaceString, true);
				if (CodeGenerationUtilities.UseFullForm (rel))
				{	// If a relationship is serializaed in full-form, then we will read the tag for the relationship itself, instead of
					// the non-anchor role-player.
					instanceName = "new" + relName.TrimStart('@');
					serializerName = instanceName + "Serializer";

#>
			DslModeling::DomainClassXmlSerializer <#= serializerName #> = serializationContext.Directory.GetSerializer(<#= relType #>.DomainClassId);
			global::System.Diagnostics.Debug.Assert(<#= serializerName #> != null, "Cannot find serializer for <#= relType #>!");
			<#= relType #> <#= instanceName #> = <#= serializerName #>.TryCreateInstance (serializationContext, reader, element.Partition) as <#= relType #>;
			if (<#= instanceName #> != null)
			{
				DslModeling::DomainRoleInfo.SetRolePlayer (<#= instanceName #>, <#= relType #>.<#= role.Name #>DomainRoleId, element);
				DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (<#= instanceName #>.GetDomainClass().Id);	
				global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + <#= instanceName #>.GetDomainClass().Name + "!");
				targetSerializer.Read(serializationContext, <#= instanceName #>, reader);
<#+
					if (!allowMultiple)
					{
#>
				break;	// Only allow one instance.
<#+
					}
#>
			}
			else
			{	// Maybe the relationship is serialized in short-form by mistake.
<#+
					if(rel.IsEmbedding)
					{					
						instanceName = "new" + childRole.RolePlayer.Name.TrimStart('@') + "Of" + relName.TrimStart('@');
						serializerName = instanceName + "Serializer";
#>
				DslModeling::DomainClassXmlSerializer <#= serializerName #> = serializationContext.Directory.GetSerializer(<#= childRoleType #>.DomainClassId);
				global::System.Diagnostics.Debug.Assert(<#= serializerName #> != null, "Cannot find serializer for <#= childRoleType #>!");
				<#= childRoleType #> <#= instanceName #> = <#= serializerName #>.TryCreateInstance(serializationContext, reader, element.Partition) as <#= childRoleType #>;
				if (<#= instanceName #> != null)
				{
					<#= behavior.Name #>SerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(<#= relType #>));
<#+
						if (role.IsPropertyGenerator && role.PropertySetterAccessModifier == AccessModifier.Public)
						{
							if (allowMultiple)
							{
#>
					element.<#= role.PropertyName #>.Add(<#= instanceName #>);
<#+
							}
							else
							{
#>
					element.<#= role.PropertyName #> = <#= instanceName #>;
<#+
							}
						}
						else
						{	// Need to create the relationship instance explicitly.
#>
					new <#= relType #>(element.Partition, new DslModeling::RoleAssignment(<#= relType #>.<#= role.Name #>DomainRoleId, element), new DslModeling::RoleAssignment(<#= relType #>.<#= childRole.Name #>DomainRoleId, <#= instanceName #>));
<#+
						}
#>
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (<#= instanceName #>.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + <#= instanceName #>.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, <#= instanceName #>, reader);
<#+
						if (!allowMultiple)
						{
#>
					break;	// Only allow one instance.
<#+
						}
#>
				}
<#+
					}	// if (rel.IsEmbedding)
					else
					{
						instanceName = "new" + childRole.RolePlayer.Name.TrimStart('@') + "MonikerOf" + relName.TrimStart('@');
						serializerName = instanceName + "Serializer";
#>
				DslModeling::DomainClassXmlSerializer <#= serializerName #> = serializationContext.Directory.GetSerializer(<#= childRoleType #>.DomainClassId);
				global::System.Diagnostics.Debug.Assert(<#= serializerName #> != null, "Cannot find serializer for <#= childRoleType #>!");
				DslModeling::Moniker <#= instanceName #> = <#= serializerName #>.TryCreateMonikerInstance(serializationContext, reader, element, <#= relType #>.DomainClassId, element.Partition);
				if (<#= instanceName #> != null)
				{
					<#= behavior.Name #>SerializationMessages.ExpectingFullFormRelationship(serializationContext, reader, typeof(<#= relType #>));
					new <#= relType #>(element.Partition, new DslModeling::RoleAssignment(<#= relType #>.<#= role.Name #>DomainRoleId, element), new DslModeling::RoleAssignment(<#= relType #>.<#= childRole.Name #>DomainRoleId, <#= instanceName #>));
					DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
<#+
						if (!allowMultiple)
						{
#>
					break;	// Only allow one instance.
<#+
						}
#>
				}
<#+
					}
#>
				else
				{	// Unknown element, skip.
					DslModeling::SerializationUtilities.Skip(reader);
				}
			}
<#+
				}
				else
				{
					if(rel.IsEmbedding)
					{					
						instanceName = "new" + childRole.RolePlayer.Name.TrimStart('@') + "Of" + relName.TrimStart('@');
						serializerName = instanceName + "Serializer";
#>
			DslModeling::DomainClassXmlSerializer <#= serializerName #> = serializationContext.Directory.GetSerializer(<#= childRoleType #>.DomainClassId);
			global::System.Diagnostics.Debug.Assert(<#= serializerName #> != null, "Cannot find serializer for <#= childRoleType #>!");
			<#= childRoleType #> <#= instanceName #> = <#= serializerName #>.TryCreateInstance(serializationContext, reader, element.Partition) as <#= childRoleType #>;
			if (<#= instanceName #> != null)
			{
<#+
						if (role.IsPropertyGenerator && role.PropertySetterAccessModifier == AccessModifier.Public)
						{
							if (allowMultiple)
							{
#>
				element.<#= role.PropertyName #>.Add(<#= instanceName #>);
<#+
							}
							else
							{
#>
				element.<#= role.PropertyName #> = <#= instanceName #>;
<#+
							}
						}
						else
						{	// Need to create the relationship instance explicitly.
#>
				new <#= relType #>(element.Partition, new DslModeling::RoleAssignment(<#= relType #>.<#= role.Name #>DomainRoleId, element), new DslModeling::RoleAssignment(<#= relType #>.<#= childRole.Name #>DomainRoleId, <#= instanceName #>));
<#+
						}
#>
				DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (<#= instanceName #>.GetDomainClass().Id);	
				global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + <#= instanceName #>.GetDomainClass().Name + "!");
				targetSerializer.Read(serializationContext, <#= instanceName #>, reader);
<#+
						if (!allowMultiple)
						{
#>
				break;	// Only allow one instance.
<#+
						}
#>
			}
<#+
					}	// if (rel.IsEmbedding)
					else
					{
						instanceName = "new" + childRole.RolePlayer.Name.TrimStart('@') + "MonikerOf" + relName.TrimStart('@');
						serializerName = instanceName + "Serializer";
#>
			DslModeling::DomainClassXmlSerializer <#= serializerName #> = serializationContext.Directory.GetSerializer(<#= childRoleType #>.DomainClassId);
			global::System.Diagnostics.Debug.Assert(<#= serializerName #> != null, "Cannot find serializer for <#= childRoleType #>!");
			DslModeling::Moniker <#= instanceName #> = <#= serializerName #>.TryCreateMonikerInstance(serializationContext, reader, element, <#= relType #>.DomainClassId, element.Partition);
			if (<#= instanceName #> != null)
			{
				new <#= relType #>(element.Partition, new DslModeling::RoleAssignment(<#= relType #>.<#= role.Name #>DomainRoleId, element), new DslModeling::RoleAssignment(<#= relType #>.<#= childRole.Name #>DomainRoleId, <#= instanceName #>));
				DslModeling::SerializationUtilities.Skip(reader);	// Moniker contains no child XML elements, so just skip.
<#+
						if (!allowMultiple)
						{
#>
				break;	// Only allow one instance.
<#+
						}
#>
			}
<#+
					}

					// If the relationship is not sealed, there can be relationships deriving it. All derived relationships will 
					// be serialized in full-form, so need to check if that's the case.
					if (rel.InheritanceModifier != InheritanceModifier.Sealed)
					{
						instanceName = "new" + relName.TrimStart('@');
						serializerName = instanceName + "Serializer";
#>
			else
			{
				global::System.Type typeof<#= relName.TrimStart('@') #> = typeof(<#= relType #>);
				DslModeling::DomainRelationshipXmlSerializer <#= serializerName #> = serializationContext.Directory.GetSerializer(<#= relType #>.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
				global::System.Diagnostics.Debug.Assert(<#= serializerName #> != null, "Cannot find serializer for <#= relType #>!");
				<#= relType #> <#= instanceName #> = <#= serializerName #>.TryCreateInstance (serializationContext, reader, element.Partition) as <#= relType #>;
				if (<#= instanceName #> != null)
				{
					if (<#= instanceName #>.GetType() == typeof<#= relName.TrimStart('@') #>)
					{	// The relationship should be serialized in short-form.
						<#= behavior.Name #>SerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(<#= relType #>));
					}
					DslModeling::DomainRoleInfo.SetRolePlayer (<#= instanceName #>, <#= relType #>.<#= role.Name #>DomainRoleId, element);
					DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer (<#= instanceName #>.GetDomainClass().Id);	
					global::System.Diagnostics.Debug.Assert (targetSerializer != null, "Cannot find serializer for " + <#= instanceName #>.GetDomainClass().Name + "!");
					targetSerializer.Read(serializationContext, <#= instanceName #>, reader);
<#+
						if (!allowMultiple)
						{
#>
					break;	// Only allow one instance.
<#+
						}
#>
				}
				else
				{	// Unknown element, skip
					DslModeling::SerializationUtilities.Skip(reader);
				}
			}
<#+
					}
					else
					{
						instanceName = "new" + relName.TrimStart('@');
						serializerName = instanceName + "Serializer";
#>
			else
			{	// Maybe the relationship is serialized in full-form by mistake.
				DslModeling::DomainRelationshipXmlSerializer <#= serializerName #> = serializationContext.Directory.GetSerializer(<#= relType #>.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
				global::System.Diagnostics.Debug.Assert(<#= serializerName #> != null, "Cannot find serializer for <#= relType #>!");
				<#= relType #> <#= instanceName #> = <#= serializerName #>.TryCreateInstance (serializationContext, reader, element.Partition) as <#= relType #>;
				if (<#= instanceName #> != null)
				{
					<#= behavior.Name #>SerializationMessages.ExpectingShortFormRelationship(serializationContext, reader, typeof(<#= relType #>));
					DslModeling::DomainRoleInfo.SetRolePlayer (<#= instanceName #>, <#= relType #>.<#= role.Name #>DomainRoleId, element);
					<#= serializerName #>.Read(serializationContext, <#= instanceName #>, reader);
<#+
						if (!allowMultiple)
						{
#>
					break;	// Only allow one instance.
<#+
						}
#>
				}
				else
				{	// Unknown element, skip
					DslModeling::SerializationUtilities.Skip(reader);
				}
			}
<#+
					}
				}
#>
		}
	}
<#+
			}
		}
	}
	
	bool isBaseRelationship = (isRelationship && !isSealed && !CodeGenerationUtilities.HasNonAbstractBaseClass (domainClass));
	if (monikerizationSupportOnly && !readSupportOnly)
	{
#>
	/// <summary>
	/// Not Supported.
	/// </summary>
	public override DslModeling::ModelElement TryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	{
		throw new global::System.NotSupportedException();
	}

	/// <summary>
	/// Not Supported.
	/// </summary>
	public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	{
		throw new global::System.NotSupportedException();
	}

	/// <summary>
	/// Not Supported.
	/// </summary>
	public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	{
		throw new global::System.NotSupportedException();
	}

<#+
	} 
	else
	{
		bool privateHelper = false;
#>

	#region TryCreateInstance<#= isRelationship ? " & TryCreateDerivedInstance" : string.Empty #>
	/// <summary>
	/// This method creates a correct instance of <#= domainClass.Name #> based on the tag currently pointed by the reader. If the reader
	/// is positioned at a serialized <#= domainClass.Name #>, a new <#= domainClass.Name #> instance will be created in the given partition, otherwise 
	/// null is returned.
	/// </summary>
	/// <remarks>
	/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	/// not move the reader; the reader should remain at the same position when this method returns.
	/// </remarks>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
	/// <param name="partition">Partition in which new elements should be created.</param>	
	/// <returns>Created <#= domainClass.Name #> instance, or null if the reader is not pointing to a serialized <#= domainClass.Name #> instance.</returns>
	public override DslModeling::ModelElement TryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	{
<#+
		if (isCustom)
		{
#>
		// IsCustom == true, calling CustomTryCreateInstance().
		// Provide your custom implementation with following signature:
		//   private DslModeling::ModelElement CustomTryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition);
		// You can call DefaultTryCreateInstance() for the default implementation.
		return this.CustomTryCreateInstance(serializationContext, reader, partition);
	}
	
	/// <summary>
	/// Default implementation of TryCreateInstance().
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	private DslModeling::ModelElement DefaultTryCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	{
<#+
		}
#>
		#region Check Parameters
		global::System.Diagnostics.Debug.Assert (serializationContext != null);
		if (serializationContext == null)
			throw new global::System.ArgumentNullException ("serializationContext");
		global::System.Diagnostics.Debug.Assert (reader != null);
		if (reader == null)
			throw new global::System.ArgumentNullException ("reader");
		global::System.Diagnostics.Debug.Assert (partition != null);
		if (partition == null)
			throw new global::System.ArgumentNullException ("partition");
		#endregion

<#+
		if (isRelationship && !isSealed && !isAbstract)
		{	// For a non-abstract non-sealed relationship, the implementation of TryCreateDerivedInstance() is almost the same as 
			// TryCreateInstance(). So we generate the actual implementation into a private helper method to re-use
			// some code.
			privateHelper = true;
#>
		return this.InternalTryCreateInstance(serializationContext, reader, partition, false /* include the type itself */);
	}

	/// <summary>
	/// This method creates a correct derived instance of <#= domainClass.Name #> based on the tag currently pointed by the reader.
	/// Note that the difference between this method and the above one is that this method will never create an instance of the
	/// <#= domainClass.Name #> type itself, only derived types are checked.
	/// </summary>
	/// <remarks>
	/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	/// not move the reader; the reader should remain at the same position when this method returns.
	/// </remarks>		
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
	/// <param name="partition">Partition in which new elements should be created.</param>
	/// <returns>Created instance that derives from <#= domainClass.Name #>, or null if the reader is not pointing to such a serialized instance.</returns>
	public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	{
		#region Check Parameters
		global::System.Diagnostics.Debug.Assert (serializationContext != null);
		if (serializationContext == null)
			throw new global::System.ArgumentNullException ("serializationContext");
		global::System.Diagnostics.Debug.Assert (reader != null);
		if (reader == null)
			throw new global::System.ArgumentNullException ("reader");
		global::System.Diagnostics.Debug.Assert (partition != null);
		if (partition == null)
			throw new global::System.ArgumentNullException ("partition");
		#endregion

		return this.InternalTryCreateInstance(serializationContext, reader, partition, true /* derived types only */) as DslModeling::ElementLink;
	}

	/// <summary>
	/// Internal helper method for TryCreateInstance() and TryCreateDerivedInstance().
	/// </summary>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
	/// <param name="partition">Partition in which new elements should be created.</param>
	/// <param name="derivedTypesOnly">If true, this method will only check derived types, but not the domain class iitself.</param>
	private DslModeling::ModelElement InternalTryCreateInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition, bool derivedTypesOnly)
	{
<#+
		}
#>
		DslModeling::ModelElement result = null;
		if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
		{
			string localName = reader.LocalName;
<#+
		if (!isAbstract)
		{
#>
			if (<#= privateHelper ? "!derivedTypesOnly && " : string.Empty #>string.Compare (localName, this.XmlTagName, global::System.StringComparison.CurrentCulture) == 0)
			{	// New "<#= domainClass.Name #>" instance.
				result = this.CreateInstance(serializationContext, reader, partition);
			}
<#+
			if (!isSealed)
			{
#>
			else
			{	// Check for derived classes of "<#= domainClass.Name #>".
				if (this.derivedClasses == null)
					this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived <#= isRelationship ? "relationship" : "class" #> instance.
					<#= serializerGenerationClassName #> derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as <#= serializerGenerationClassName #>;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
				}
			}
<#+
			}
		}
		else
		{
#>
			// Check for derived classes of "<#= domainClass.Name #>".
			if (this.derivedClasses == null)
				this.ConstructDerivedClassesLookupTable(serializationContext, partition.DomainDataDirectory);
			global::System.Diagnostics.Debug.Assert (this.derivedClasses != null);
			DslModeling::DomainClassInfo derivedClass = null;
			if (this.derivedClasses.TryGetValue (localName, out derivedClass) && derivedClass != null)
			{	// New derived <#= isRelationship ? "relationship" : "class" #> instance.
				<#= serializerGenerationClassName #> derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as <#= serializerGenerationClassName #>;
				global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
				result = derivedSerializer.CreateInstance(serializationContext, reader, partition);
			}
<#+
		}
#>
		}

		return result;
	}

	/// <summary>
	/// This method creates an instance of <#= domainClass.Name #> based on the tag currently pointed by the reader. The reader is guaranteed (by the caller)
	/// to be pointed at a serialized instance of <#= domainClass.Name #>.
	/// </summary>
	/// <remarks>
	/// The caller will guarantee that the reader is positioned at open XML tag of the ModelRoot instance being read. This method should
	/// not move the reader; the reader should remain at the same position when this method returns.
	/// </remarks>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
	/// <param name="partition">Partition in which new <#= domainClass.Name #> instance should be created.</param>	
	/// <returns>Created <#= domainClass.Name #> instance.</returns>
	protected override DslModeling::ModelElement CreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	{
<#+
		if (isCustom)
		{
#>
		// IsCustom == true, calling CustomCreateInstance().
		// Provide your custom implementation with following signature:
		//   private DslModeling::ModelElement CustomCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition);
		// You can call DefaultCreateInstance() for the default implementation.
		return this.CustomCreateInstance(serializationContext, reader, partition);
	}
	
	/// <summary>
	/// Default implementation of CreateInstance().
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId="serializationContext", Justification = "Matching the signature of CustomCreateInstance.")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId="reader", Justification = "Matching the signature of CustomCreateInstance.")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId="partition", Justification = "Matching the signature of CustomCreateInstance.")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMethodsAsStatic", Justification = "Matching the signature of CustomCreateInstance.")]
	private DslModeling::ModelElement DefaultCreateInstance(DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
	{
<#+
		}

		if (isAbstract)
		{
#>
		// Abstract class, cannot be serialized.
		throw new global::System.NotSupportedException();
<#+
		}
		else
		{
			if (monikerDataDC.SerializeId)
			{
#>
		string idStr = reader.GetAttribute ("Id");
		try
		{
			global::System.Guid id;
			if (string.IsNullOrEmpty(idStr))
			{	// Create a default Id.
				id = global::System.Guid.NewGuid();
				<#= behavior.Name #>SerializationMessages.MissingId(serializationContext, reader, id);
			}
			else
			{
				id = new global::System.Guid (idStr);
			}
<#+
				if (!isRelationship)
				{
#>
			return new <#= classTypeString #>(partition, new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id));
<#+
				}
				else
				{
					DomainRole nonAnchorRole = (domainClass as DomainRelationship).Target;
					DomainRole anchorRole = nonAnchorRole.Opposite;
#>
			// Create the link with place-holder role-players.
			return new <#= classTypeString #>(
				partition,
				new DslModeling::RoleAssignment[] {
					DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (<#= classTypeString #>.<#= anchorRole.Name #>DomainRoleId), 
					DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (<#= classTypeString #>.<#= nonAnchorRole.Name #>DomainRoleId)
				},
				new DslModeling::PropertyAssignment[] {
					new DslModeling::PropertyAssignment(DslModeling::ElementFactory.IdPropertyAssignment, id)
				}
			);
<#+
				}
#>
		}
		catch (global::System.ArgumentNullException /* anEx */)
		{	
			<#= behavior.Name #>SerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
		}
		catch (global::System.FormatException /* fEx */)
		{
			<#= behavior.Name #>SerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
		}
		catch (global::System.OverflowException /* ofEx */)
		{
			<#= behavior.Name #>SerializationMessages.InvalidPropertyValue(serializationContext, reader, "Id", typeof(global::System.Guid), idStr);
		}
		return null;
<#+
			}
			else
			{
				if (!isRelationship)
				{
#>
		return new <#= classTypeString #>(partition);
<#+
				}
				else
				{
					DomainRole nonAnchorRole = (domainClass as DomainRelationship).Target;
					DomainRole anchorRole = nonAnchorRole.Opposite;
#>
		// Create the link with place-holder role-players.
		return new <#= classTypeString #>(
			partition,
			DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (<#= classTypeString #>.<#= anchorRole.Name #>DomainRoleId), 
			DslModeling::RoleAssignment.CreatePlaceholderRoleAssignment (<#= classTypeString #>.<#= nonAnchorRole.Name #>DomainRoleId)
		);
<#+
				}
			}
		}
#>
	}
<#+
		if (isRelationship && !privateHelper)
		{
#>

	/// <summary>
	/// This method creates a correct derived instance of <#= domainClass.Name #> based on the tag currently pointed by the reader.
	/// Note that the difference between this method and the above one is that this method will never create an instance of the
	/// <#= domainClass.Name #> type itself, only derived types are checked.
	/// </summary>
	/// <remarks>
	/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	/// not move the reader; the reader should remain at the same position when this method returns.
	/// </remarks>		
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
	/// <param name="partition">Partition in which new elements should be created.</param>
	/// <returns>Created instance that derives from <#= domainClass.Name #>, or null if the reader is not pointing to such a serialized instance.</returns>
	public override DslModeling::ElementLink TryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
<#+
			if (isCustom)
			{
#>
	{	// IsCustom == true, calling CustomTryCreateDerivedInstance().
		// Provide your custom implementation with following signature:
		//   private DslModeling::ElementLink CustomTryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition);
		// You can call DefaultTryCreateDerivedInstance() for the default implementation.
		return this.CustomTryCreateDerivedInstance(serializationContext, reader, partition);
	}
	
	/// <summary>
	/// Default implementation of TryCreateDerivedInstance().
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	private DslModeling::ElementLink DefaultTryCreateDerivedInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::Partition partition)
<#+
			}
			
			if (isAbstract)
			{	// For abstract relationship, TryCreateDerivedInstance() and TryCreateInstance() will be the same
#>
	{	// Abstract relationship, so it's the same as TryCreateInstance().
		return this.TryCreateInstance(serializationContext, reader, partition) as DslModeling::ElementLink;
<#+
			}
			else // Must be sealed.
			{	// Sealed relationship won't have derived instances.		
#>
	{	// Sealed relationship, won't have any derived instances.
		return null;
<#+
			}
#>
	}
<#+
		}

		if (!isSealed)
		{	
#>

	/// <summary>
	/// Stores a mapping from XmlTagName to DomainClassInfo that derives from <#= domainClass.Name #>, created on demand.
	/// </summary>
	private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClasses;

	/// <summary>
	/// Construct the apping from XmlTagName to DomainClassInfo that derives from <#= domainClass.Name #>.
	/// </summary>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	private void ConstructDerivedClassesLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	{
		global::System.Diagnostics.Debug.Assert(this.derivedClasses == null); // Shouldn't construct the table more than once.
		this.derivedClasses = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);

		DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(<#= classTypeString #>.DomainClassId);
		global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");

		global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
		if (descendents != null)
		{
			foreach (DslModeling::DomainClassInfo descendent in descendents)
			{
				global::System.Type descendentType = descendent.ImplementationClass;
				if (!descendentType.IsAbstract)
				{
					DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
					if (descendentSerializer != null)
					{
						string descendentXmlTagName = descendentSerializer.XmlTagName;
						if (!string.IsNullOrEmpty (descendentXmlTagName))
						{
							global::System.Diagnostics.Debug.Assert(!this.derivedClasses.ContainsKey (descendentXmlTagName));
							this.derivedClasses.Add (descendentXmlTagName, descendent);
						}
					}
				}
				else
				{   // Ignore abstract derived classes because they cannot be instantiated directly.
				}
			}
		}
	}
<#+
		}
#>
	#endregion

	#region TryCreateMonikerInstance
	/// <summary>
	/// This method creates a Moniker of the correct derived (including <#= domainClass.Name #> itself) instance of <#= domainClass.Name #> based on the tag currently pointed by the reader.
	/// </summary>
	/// <remarks>
	/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	/// not move the reader; the reader should remain at the same position when this method returns.
	/// </remarks>		
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
	/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
	/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	public override DslModeling::Moniker TryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	{
<#+
		if (isCustom)
		{
#>
		// IsCustom == true, calling CustomTryCreateMonikerInstance().
		// Provide your custom implementation with following signature:
		//   private DslModeling::Moniker CustomTryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition);
		// You can call DefaultTryCreateMonikerInstance() for the default implementation.
		return this.CustomTryCreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	}
	
	/// <summary>
	/// Default implementation of TryCreateMonikerInstance().
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	private DslModeling::Moniker DefaultTryCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	{
<#+
		}
#>
		#region Check Parameters
		global::System.Diagnostics.Debug.Assert (serializationContext != null);
		if (serializationContext == null)
			throw new global::System.ArgumentNullException ("serializationContext");
		global::System.Diagnostics.Debug.Assert (reader != null);
		if (reader == null)
			throw new global::System.ArgumentNullException ("reader");
		global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
		if (sourceRolePlayer == null)
			throw new global::System.ArgumentNullException ("sourceRolePlayer");
		global::System.Diagnostics.Debug.Assert (partition != null);
		if (partition == null)
			throw new global::System.ArgumentNullException ("partition");
		#endregion

		DslModeling::Moniker result = null;
		if (!serializationContext.Result.Failed && !reader.EOF && reader.NodeType == global::System.Xml.XmlNodeType.Element)
		{
			string localName = reader.LocalName;
<#+
		if (!isAbstract)
		{
#>
			if (string.Compare (localName, this.MonikerTagName, global::System.StringComparison.CurrentCulture) == 0)
			{	// New "<#= domainClass.Name #>" moniker instance.
				result = this.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
			}
<#+
			if (!isSealed)
			{
#>
			else
			{	// Check for derived classes of "<#= domainClass.Name #>".
				if (this.derivedClassMonikers == null)
					this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
				global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
				DslModeling::DomainClassInfo derivedClass = null;
				if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
				{	// New derived class moniker instance.
					<#= serializerGenerationClassName #> derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as <#= serializerGenerationClassName #>;
					global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
					result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
				}
			}
<#+
			}
		}
		else
		{
#>
			// Check for derived classes of "<#= domainClass.Name #>".
			if (this.derivedClassMonikers == null)
				this.ConstructDerivedClassMonikersLookupTable(serializationContext, partition.DomainDataDirectory);
			global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers != null);
			DslModeling::DomainClassInfo derivedClass = null;
			if (this.derivedClassMonikers.TryGetValue (localName, out derivedClass) && derivedClass != null)
			{	// New derived class moniker instance.
				<#= serializerGenerationClassName #> derivedSerializer = serializationContext.Directory.GetSerializer(derivedClass.Id) as <#= serializerGenerationClassName #>;
				global::System.Diagnostics.Debug.Assert(derivedSerializer != null, "Cannot find serializer for " + derivedClass.Name + "!");
				result = derivedSerializer.CreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
			}
<#+
		}
#>
		}

		return result;
	}
	
	/// <summary>
	/// This method creates a Moniker of <#= domainClass.Name #> based on the tag currently pointed by the reader.
	/// </summary>
	/// <remarks>
	/// The caller will guarantee that the reader is positioned at open XML tag of the next element being read. This method should
	/// not move the reader; the reader should remain at the same position when this method returns.
	/// </remarks>		
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="reader">XmlReader to read serialized data from.</param>
	/// <param name="sourceRolePlayer">The source role-player instance from which the moniker being created is referenced.</param>
	/// <param name="relDomainClassId">The DomainClass Id of the relationship that connects the sourceRolePlayer to the moniker being created.</param>
	/// <param name="partition">The new Moniker should be created in the Store associated with this partition.</param>			
	/// <returns>Created ModelRoot instance, or null if the reader is not pointing to a correct monikerized instance.</returns>
	protected override DslModeling::Moniker CreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	{
<#+
		if (isCustom)
		{
#>
		// IsCustom == true, calling CustomCreateMonikerInstance().
		// Provide your custom implementation with following signature:
		//   private DslModeling::Moniker CustomCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition);
		// You can call DefaultCreateMonikerInstance() for the default implementation.
		return this.CustomCreateMonikerInstance(serializationContext, reader, sourceRolePlayer, relDomainClassId, partition);
	}
	
	/// <summary>
	/// Default implementation of CreateMonikerInstance().
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId="serializationContext", Justification = "Matching the signature of CustomCreateMonikerInstance.")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId="reader", Justification = "Matching the signature of CustomCreateMonikerInstance.")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId="sourceRolePlayer", Justification = "Matching the signature of CustomCreateMonikerInstance.")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId="relDomainClassId", Justification = "Matching the signature of CustomCreateMonikerInstance.")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId="partition", Justification = "Matching the signature of CustomCreateMonikerInstance.")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMethodsAsStatic", Justification = "Matching the signature of CustomCreateMonikerInstance.")]
	private DslModeling::Moniker DefaultCreateMonikerInstance (DslModeling::SerializationContext serializationContext, global::System.Xml.XmlReader reader, DslModeling::ModelElement sourceRolePlayer, global::System.Guid relDomainClassId, DslModeling::Partition partition)
	{
<#+
		}
		if (monikerDataDC.MonikerKind == MonikerKind.None)
		{
#>
		// Cannot be monikerized.
		throw new global::System.NotSupportedException();
<#+
		}
		else
		{
#>
		string monikerString = <#= behavior.DslLibrary.Name #>SerializationHelper.Instance.ReadAttribute(serializationContext, sourceRolePlayer, reader, this.MonikerAttributeName);

		if (string.IsNullOrEmpty(monikerString))
		{	
			<#= behavior.Name #>SerializationMessages.MissingMoniker(serializationContext, reader, this.MonikerAttributeName);
			return null;
		}
<#+
			switch (monikerDataDC.MonikerKind)
			{
				case MonikerKind.Normal:
#>
		DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(relDomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
		global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for DomainRelationship with Id " + relDomainClassId + "!");
		DslModeling::Moniker result = relSerializer.MonikerizeReference(serializationContext, sourceRolePlayer, <#= classTypeString #>.DomainClassId, monikerString, partition.Store);
		// Set location info if possible.
		result.Location = serializationContext.Location;
		global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
		if (xmlLineInfo != null)
		{
			result.Line = xmlLineInfo.LineNumber;
			result.Column = xmlLineInfo.LinePosition;
		}
		return result;
<#+
					break;
				case MonikerKind.Id:
#>
		try
		{	// Normalize the Id.
			global::System.Guid id = new global::System.Guid(monikerString);
			monikerString = id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture);
			DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, <#= classTypeString #>.DomainClassId, partition.Store), partition.Store);
			// Set location info if possible.
			result.Location = serializationContext.Location;
			global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
			if (xmlLineInfo != null)
			{
				result.Line = xmlLineInfo.LineNumber;
				result.Column = xmlLineInfo.LinePosition;
			}
			return result;
		}
		catch (global::System.FormatException /* fEx */)
		{
			<#= behavior.Name #>SerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
			return null;
		}
		catch (global::System.OverflowException /* oEx */)
		{	
			<#= behavior.Name #>SerializationMessages.InvalidPropertyValue(serializationContext, reader, this.MonikerAttributeName, typeof(global::System.Guid), monikerString);
			return null;
		}
<#+
					break;
				case MonikerKind.Custom:
				default:
#>
		DslModeling::Moniker result = new DslModeling::Moniker(new DslModeling::MonikerKey(monikerString, relDomainClassId, <#= classTypeString #>.DomainClassId, partition.Store), partition.Store);
		// Set location info if possible.
		result.Location = serializationContext.Location;
		global::System.Xml.IXmlLineInfo xmlLineInfo = reader as global::System.Xml.IXmlLineInfo;
		if (xmlLineInfo != null)
		{
			result.Line = xmlLineInfo.LineNumber;
			result.Column = xmlLineInfo.LinePosition;
		}
		return result;
<#+
					break;
			}
		}
#>
	}
<#+
		if (!isSealed)
		{	
#>

	/// <summary>
	/// Stores a mapping from Moniker Xml tag name to DomainClassInfo that derives from <#= domainClass.Name #>, created on demand.
	/// </summary>
	private global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> derivedClassMonikers;

	/// <summary>
	/// Construct the mapping from Moniker Xml tag name to DomainClassInfo that derives from <#= domainClass.Name #>.
	/// </summary>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="domainDataDirectory">DomainDataDirectory to be used to discover all derived classes.</param>
	private void ConstructDerivedClassMonikersLookupTable(DslModeling::SerializationContext serializationContext, DslModeling::DomainDataDirectory domainDataDirectory)
	{
		global::System.Diagnostics.Debug.Assert(this.derivedClassMonikers == null); // Shouldn't construct the table more than once.
		this.derivedClassMonikers = new global::System.Collections.Generic.Dictionary<string, DslModeling::DomainClassInfo> (global::System.StringComparer.CurrentCulture);

		DslModeling::DomainClassInfo thisClass = domainDataDirectory.GetDomainClass(<#= classTypeString #>.DomainClassId);
		global::System.Diagnostics.Debug.Assert(thisClass != null, "Cannot find DomainClassInfo for ModelRoot!");

		global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::DomainClassInfo> descendents = thisClass.AllDescendants;
		if (descendents != null)
		{
			foreach (DslModeling::DomainClassInfo descendent in descendents)
			{
				DslModeling::DomainClassXmlSerializer descendentSerializer = serializationContext.Directory.GetSerializer(descendent.Id);
				if (descendentSerializer != null)
				{
					string descendentMonikerTagName = descendentSerializer.MonikerTagName;
					if (!string.IsNullOrEmpty (descendentMonikerTagName))
					{
						global::System.Diagnostics.Debug.Assert(!this.derivedClassMonikers.ContainsKey (descendentMonikerTagName));
						this.derivedClassMonikers.Add (descendentMonikerTagName, descendent);
					}
				}
			}
		}
	}
<#+
		}
#>
	#endregion
	#endregion
<#+
	} 
	if (readSupportOnly)
	{
#>

	#region Not-supported Base Methods
<#+
	}
	
	if (monikerizationSupportOnly || readSupportOnly)
	{
#>
	/// <summary>
	/// Not Supported.
	/// </summary>
	public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	{
		throw new global::System.NotSupportedException ();
	}
	
<#+
	}
	else
	{
#>

	#region Write Methods
	/// <summary>
	/// Public WriteMoniker() method that writes a monikerized <#= domainClass.Name #> instance into XML.
	/// </summary>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="element"><#= domainClass.Name #> instance to be monikerized.</param>
	/// <param name="writer">XmlWriter to write serialized data to.</param>
	/// <param name="sourceRolePlayer">Source element that references the <#= domainClass.Name #> instance being monikerized.</param>
	/// <param name="relSerializer">Serializer that handles the relationship connecting the source element to the <#= domainClass.Name #> instance being monikerized.</param>
	public override void WriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	{
<#+
		if (!generateMonikerHelpers || isAbstract)
		{
#>
		// Instance of <#= domainClass.Name #> cannot be monikerized.
		<#= behavior.Name #>SerializationMessages.CannotMonikerizeElement(serializationContext, "<#= domainClass.Name #>");
<#+
		}
		else
		{
			if (isCustom)
			{
#>
		// IsCustom == true, calling CustomWriteMoniker().
		// Provide your custom implementation with following signature:
		//   private void CustomWriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer);
		// You can call DefaultWriteMoniker() for the default implementation.
		this.CustomWriteMoniker(serializationContext, element, writer, sourceRolePlayer, relSerializer);
	}
	
	/// <summary>
	/// Default implementation of WriteMoniker().
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	private void DefaultWriteMoniker(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::ModelElement sourceRolePlayer, DslModeling::DomainRelationshipXmlSerializer relSerializer)
	{
<#+
			}
#>
		#region Check Parameters
		global::System.Diagnostics.Debug.Assert (serializationContext != null);
		if (serializationContext == null)
			throw new global::System.ArgumentNullException ("serializationContext");
		global::System.Diagnostics.Debug.Assert (element != null);
		if (element == null)
			throw new global::System.ArgumentNullException ("element");
		global::System.Diagnostics.Debug.Assert (writer != null);
		if (writer == null)
			throw new global::System.ArgumentNullException ("writer");
		global::System.Diagnostics.Debug.Assert (sourceRolePlayer != null);
		if (sourceRolePlayer == null)
			throw new global::System.ArgumentNullException ("sourceRolePlayer");
		global::System.Diagnostics.Debug.Assert (relSerializer != null);
		if (relSerializer == null)
			throw new global::System.ArgumentNullException ("relSerializer");
		#endregion
		
<#+
			if (monikerDataDC.MonikerKind == MonikerKind.Normal)
			{
#>
		string monikerString = relSerializer.SerializeReference(serializationContext, sourceRolePlayer, element);
<#+
			}
			else
			{
#>
		string monikerString = this.CalculateQualifiedName(serializationContext.Directory, element);
<#+
			}
#>
		global::System.Diagnostics.Debug.Assert(!string.IsNullOrEmpty(monikerString));
		writer.WriteStartElement(this.MonikerTagName);
		<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, this.MonikerAttributeName, monikerString);
		writer.WriteEndElement();
<#+
		}
#>
	}
	
<#+
	}

	bool isShortFormRelationship = (isRelationship && !CodeGenerationUtilities.UseFullForm((DomainRelationship)domainClass));
	if (monikerizationSupportOnly || readSupportOnly)
	{
#>
	/// <summary>
	/// Not Supported.
	/// </summary>
	public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	{
		throw new global::System.NotSupportedException();
	}
<#+
	} 
	else
	{
#>
	/// <summary>
	/// Public Write() method that serializes one <#= domainClass.Name #> instance into XML.
	/// </summary>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="element"><#= domainClass.Name #> instance to be serialized.</param>
	/// <param name="writer">XmlWriter to write serialized data to.</param>
	/// <param name="rootElementSettings">
	/// The root element settings if the passed in element is serialized as a root element in the XML. The root element contains additional
	/// information like schema target namespace, version, etc.
	/// This should only be passed for root-level elements. Null should be passed for rest elements (and ideally call the Write() method 
	/// without this parameter).
	/// </param>
<#+
		if (isAbstract || isShortFormRelationship)
		{
#>
	public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	{
		throw new global::System.NotSupportedException();
	}
<#+
		}
		else
		{
#>
	public override void Write(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	{
<#+
			if (isCustom)
			{
#>
		// IsCustom == true, calling CustomWrite().
		// Provide your custom implementation with following signature:
		//   private void CustomWrite(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings);
		// You can call DefaultWrite() for the default implementation.
		this.CustomWrite(serializationContext, element, writer, rootElementSettings);
	}
	
	/// <summary>
	/// Default implementation of Write().
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	private void DefaultWrite(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer, DslModeling::RootElementSettings rootElementSettings)
	{
<#+
			}
#>
		#region Check Parameters
		global::System.Diagnostics.Debug.Assert (serializationContext != null);
		if (serializationContext == null)
			throw new global::System.ArgumentNullException ("serializationContext");
		global::System.Diagnostics.Debug.Assert (element != null);
		if (element == null)
			throw new global::System.ArgumentNullException ("element");
		global::System.Diagnostics.Debug.Assert (writer != null);
		if (writer == null)
			throw new global::System.ArgumentNullException ("writer");
		#endregion

		// Write start of element, including schema target namespace if specified.
		if (rootElementSettings != null && !string.IsNullOrEmpty(rootElementSettings.SchemaTargetNamespace))
		{
			writer.WriteStartElement(this.XmlTagName, rootElementSettings.SchemaTargetNamespace);
			DslModeling::SerializationUtilities.WriteDomainModelNamespaces(serializationContext.Directory, writer, rootElementSettings.SchemaTargetNamespace);
		}
		else
		{
			writer.WriteStartElement(this.XmlTagName);
		}
			
		// Write version info (in the format 1.2.3.4), if necessary
		if (rootElementSettings != null && rootElementSettings.Version != null)
			writer.WriteAttributeString("dslVersion", rootElementSettings.Version.ToString(4));
<#+
			if (monikerDataDC.SerializeId)
			{
#>

		// Write out element Id.
		writer.WriteAttributeString("Id", element.Id.ToString("D", global::System.Globalization.CultureInfo.CurrentCulture));
<#+
			}
			
			bool assertInstanceType = true;

			if (generateAttributePropertiesWriteMethods)
			{
#>

		WritePropertiesAsAttributes(serializationContext, element, writer);

<#+
			}
			else if (!isRootClass && attribProps.Count == 0)
			{	// This class defines no additional properties that will be serialized as XML attributes.
#>

		base.WritePropertiesAsAttributes(serializationContext, element, writer);

<#+
			}
#>
		// Write out any extension data if this is the root element
		if (rootElementSettings != null && !serializationContext.Result.Failed)
		{
			<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.WriteExtensions(serializationContext, element, writer);
		}

<#+
			if (isRelationship)
			{	
#>
		// Write the target role-player instance.
<#+
				// If target end is monikerized, write a reference it, otherwise write it directly.
				DomainRole targetRole = (domainClass as DomainRelationship).Target;
				DomainClass targetRolePlayer = targetRole.RolePlayer;
				if (assertInstanceType)
				{
#>
		<#= classTypeString #> instance = element as <#= classTypeString #>;
		global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of <#= classTypeString #>!");

<#+
					assertInstanceType = false;
				}
#>
		DslModeling::ModelElement targetElement = instance.<#= targetRole.Name #>;
<#+
				if (!((DomainRelationship)domainClass).IsEmbedding)
				{
#>
		DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
		global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
		targetSerializer.WriteMoniker(serializationContext, targetElement, writer, instance.<#= targetRole.Opposite.Name #>, this);

<#+
				}
				else
				{
#>
		DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
		global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");
		targetSerializer.Write(serializationContext, targetElement, writer);

<#+
				}			
			}

			if (elementProps.Count == calculatedElementPropCount && roles.Count == 0 && isRootClass && isSealed)
			{	// This class is root and sealed, which means it can't contain any nested XML elements in it.
				// So no need to write anything, except for calculated properties (read-only ones).
				if (calculatedElementPropCount > 0)
				{
					if (assertInstanceType)
					{
#>
		<#= classTypeString #> instance = element as <#= classTypeString #>;
		global::System.Diagnostics.Debug.Assert(instance != null, "Expecting an instance of <#= classTypeString #>!");
<#+
						assertInstanceType = false;
					}
#>
		WritePropertiesAsElements(serializationContext, instance, writer);

<#+
				}
			}
			else
			{
#>
		if (!serializationContext.Result.Failed)
		{
			// Write 1) properties serialized as nested XML elements and 2) child model elements into XML.
<#+
				if (generateElementsMethods)
				{
#>
			WriteElements(serializationContext, element, writer);
<#+
				}
				else
				{
#>
			base.WriteElements(serializationContext, element, writer);
<#+
				}
#>
		}

<#+
			}
#>
		writer.WriteEndElement();
	}
<#+
		}
	}
	
	// For a sealed relationship serialized in short-form, there's no point to generate WritePropertiesAsAttributes() method,
	// because it will never be called.
	if (isShortFormRelationship && isSealed && attribProps.Count == 0)
		generateAttributePropertiesWriteMethods = false;
		
	if (generateAttributePropertiesWriteMethods)
	{
			
#>

	/// <summary>
	/// Write all properties that need to be serialized as XML attributes.
	/// </summary>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="element"><#= domainClass.Name #> instance to be serialized.</param>
	/// <param name="writer">XmlWriter to write serialized data to.</param> 
<#+
		if (isCustom)
		{	
			// This gen'ed might not be used. It only be used if user invokes the DefaultRead
#>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]

<#+
		}
		else
		{
#>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
<#+
		}
#>
	protected override void WritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	{
<#+
		if (isCustom)
		{
#>
		// IsCustom == true, calling CustomWritePropertiesAsAttributes().
		// Provide your custom implementation with following signature:
		//   private void CustomWritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer);
		// You can call DefaultWritePropertiesAsAttributes() for the default implementation.
		CustomWritePropertiesAsAttributes(serializationContext, element, writer);
	}
	
	/// <summary>
	/// Default implementation of WritePropertiesAsAttributes().
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	private void DefaultWritePropertiesAsAttributes(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	{
<#+
		}
		
#>
		// Always call the base class so any extensions are serialized
		base.WritePropertiesAsAttributes(serializationContext, element, writer);

<#+
		
		if (attribProps.Count == 0)
		{
#>
		// There are no properties; do nothing
<#+
		}
		else
		{
			string instanceName = "instanceOf" + domainClass.Name.TrimStart('@');
#>
		<#= classTypeString #> <#= instanceName #> = element as <#= classTypeString #>;
		global::System.Diagnostics.Debug.Assert(<#= instanceName #> != null, "Expecting an instance of <#= domainClass.Name #>");

<#+
			// Note: no need to sort the properties here, because they should have already been sorted when generating ReadAttributes() method.
			foreach(DomainProperty attribProp in attribProps)
			{
				if (attribProp.Kind == PropertyKind.Calculated)
				{
#>
		// <#= attribProp.Name #>, calculated property, will be ignored on deserialization.
<#+
				}
				else
				{
#>
		// <#= attribProp.Name #>
<#+
				}
#>
		if (!serializationContext.Result.Failed)
		{
<#+
				string propValueInstance = "propValue";
				if (attribProp.GetterAccessModifier == AccessModifier.Public)
				{
#>
			<#= attribProp.Type.GetRelativeName(namespaceString, true) #> propValue = <#= instanceName #>.<#= attribProp.Name #>;
<#+
				}
				else
				{
#>
			// Non-public getter, use DomainPropertyInfo method.
			DslModeling::DomainPropertyInfo propInfo = <#= instanceName #>.Partition.DomainDataDirectory.GetDomainProperty (<#= classTypeString #>.<#= attribProp.Name #>DomainPropertyId);
			global::System.Diagnostics.Debug.Assert (propInfo != null, "Cannot get DomainPropertyInfo for <#= classTypeString #>.<#= attribProp.Name #>!");
			<#= attribProp.Type.GetRelativeName(namespaceString, true) #> propValue = ((<#= attribProp.Type.GetRelativeName(namespaceString, true) #>)propInfo.GetValue(<#= instanceName #>));
<#+
				}
				bool stringProp = CodeGenerationUtilities.IsStringProperty(attribProp);
				if (!stringProp)
				{
#>
			string serializedPropValue = DslModeling::SerializationUtilities.GetString<<#= attribProp.Type.GetRelativeName(namespaceString, true) #>>(serializationContext, propValue);
<#+
					propValueInstance = "serializedPropValue";
				}
#>
			if (!serializationContext.Result.Failed)
			{
<#+
				string attribPropTagName = CodeGenerationUtilities.GetPropertyTagName (attribProp);

				if ((monikerDataDC.KeyProperty != null && monikerDataDC.KeyProperty.Id == attribProp.Id) ||
					(monikerDataDC.QualifierProperty != null && monikerDataDC.QualifierProperty.Id == attribProp.Id))
				{
#>
				<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "<#= attribPropTagName #>", <#= propValueInstance #>);
<#+
				}
				else if (attribProp.DefaultValue == null)
				{
					if (!stringProp)
					{
#>
				<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "<#= attribPropTagName #>", <#= propValueInstance #>);
<#+
					}
					else if (attribProp.Kind == PropertyKind.Normal)
					{
#>
				if (!string.IsNullOrEmpty(<#= propValueInstance #>))
					<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "<#= attribPropTagName #>", <#= propValueInstance #>);

<#+
					}
					else
					{
#>
				if (<#= propValueInstance #> != null)
					<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "<#= attribPropTagName #>", <#= propValueInstance #>);
<#+
					}
				}
				else
				{	// Generate code to check if the property is the same as default value, if so, there's no need to write the value out.
					if (stringProp)
					{
#>
				if (<#= propValueInstance #> != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(<#= propValueInstance #>, <#= CodeGenerationUtilities.WrapAsCSharpString(attribProp.DefaultValue) #>) != 0))
				{	// No need to write the value out if it's the same as default value.
					<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "<#= attribPropTagName #>", <#= propValueInstance #>);
				}
<#+
					}
					else
					{
#>
				if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(<#= propValueInstance #>, <#= CodeGenerationUtilities.WrapAsCSharpString(attribProp.DefaultValue) #>) != 0)
				{	// No need to write the value out if it's the same as default value.
					<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.WriteAttributeString(serializationContext, element, writer, "<#= attribPropTagName #>", <#= propValueInstance #>);
				}
<#+
					}
				}
#>
			}
		}
<#+
			}
		}
#>
	}
<#+
	}

	// For a sealed relationship serialized in short-form, there's no point to generate WriteElements() method,
	// because it will never be called.
	if (isShortFormRelationship && isSealed && !(generateElementPropertiesWriteMethods || generateChildElementsMethods))
		generateElementsMethods = false;
	if (generateElementsMethods)
	{
		
#>

	/// <summary>
	/// This methods serializes 1) properties serialized as nested XML elements and 2) child model elements into XML. 
	/// </summary>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="element"><#= domainClass.Name #> instance to be serialized.</param>
	/// <param name="writer">XmlWriter to write serialized data to.</param>        
<#+
		if (isCustom)
		{
#>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
<#+
		}
#>
	protected override void WriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	{
<#+
		if (isCustom)
		{
#>
		// IsCustom == true, calling CustomWriteElements().
		// Provide your custom implementation with following signature:
		//   private void CustomWriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer);
		// You can call DefaultWriteElements() for the default implementation.
		CustomWriteElements(serializationContext, element, writer);
	}
	
	/// <summary>
	/// Default implementation of WriteElements().
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	private void DefaultWriteElements(DslModeling::SerializationContext serializationContext, DslModeling::ModelElement element, global::System.Xml.XmlWriter writer)
	{
<#+
		}
		
#>
		// Always call the base class so any extensions are serialized
		base.WriteElements(serializationContext, element, writer);

<#+
		
		string instanceName = "instance";
		if (generateElementPropertiesWriteMethods || generateChildElementsMethods)
		{
#>
		<#= classTypeString #> <#= instanceName #> = element as <#= classTypeString #>;
		global::System.Diagnostics.Debug.Assert(<#= instanceName #> != null, "Expecting an instance of <#= domainClass.Name #>!");

<#+
		}
		if (generateElementPropertiesWriteMethods)
		{
#>
		// Write properties serialized as nested XML elements.
		if (!serializationContext.Result.Failed)
			WritePropertiesAsElements(serializationContext, <#= instanceName #>, writer);
<#+
		}
		if (generateChildElementsMethods)
		{
#>
		// Write child model elements (which are always serialized as nested XML elements).
		if (!serializationContext.Result.Failed)
			WriteChildElements(serializationContext, <#= instanceName #>, writer);
<#+
		}
#>
	}
	
<#+
	}

	if (generateElementPropertiesWriteMethods)
	{
#>

	/// <summary>
	/// Serialize all properties that need to be stored as nested XML elements.
	/// </summary>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="element"><#= domainClass.Name #> instance to be serialized.</param>
	/// <param name="writer">XmlWriter to write serialized data to.</param>
<#+
		if (isCustom)
		{
#>		
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
<#+
		}
		else
		{
#>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
<#+
		}
#>
	private static void WritePropertiesAsElements(DslModeling::SerializationContext serializationContext, <#= classTypeString #> element, global::System.Xml.XmlWriter writer)
	{
<#+
		if (isCustom)
		{
#>
		// IsCustom == true, calling CustomWritePropertiesAsElements().
		// Provide your custom implementation with following signature:
		//   private static void CustomWritePropertiesAsElements(DslModeling::SerializationContext serializationContext, <#= classTypeString #> element, global::System.Xml.XmlWriter writer);
		// You can call DefaultWritePropertiesAsElements() for the default implementation.
		CustomWritePropertiesAsElements(serializationContext, element, writer);
	}
	
	/// <summary>
	/// Default implementation of WritePropertiesAsElements().
	/// </summary>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "Provided to help custom implementation")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	private static void DefaultWritePropertiesAsElements(DslModeling::SerializationContext serializationContext, <#= classTypeString #> element, global::System.Xml.XmlWriter writer)
	{
<#+
		}
		// Note: no need to sort the properties here, because they should have already been sorted when generating ReadPropertiesFromElements() method.
		foreach(DomainProperty elementProp in elementProps)
		{
			if (elementProp.Kind == PropertyKind.Calculated)
			{
#>
		// <#= elementProp.Name #>, calculated property, will be ignored on deserialization.
<#+
			}
			else
			{
#>
		// <#= elementProp.Name #>
<#+
			}

#>
		if (!serializationContext.Result.Failed)
		{
<#+
			string propValueInstance = "propValue";
			if (elementProp.GetterAccessModifier == AccessModifier.Public)
			{
#>
			<#= elementProp.Type.GetRelativeName(namespaceString, true) #> propValue = element.<#= elementProp.Name #>;
<#+
			}
			else
			{
#>
			// Non-public getter, use DomainPropertyInfo method.
			DslModeling::DomainPropertyInfo propInfo = element.Partition.DomainDataDirectory.GetDomainProperty (<#= classTypeString #>.<#= elementProp.Name #>DomainPropertyId);
			global::System.Diagnostics.Debug.Assert (propInfo != null, "Cannot get DomainPropertyInfo for <#= classTypeString #>.<#= elementProp.Name #>!");
			<#= elementProp.Type.GetRelativeName(namespaceString, true) #> propValue = ((<#= elementProp.Type.GetRelativeName(namespaceString, true) #>)propInfo.GetValue(element));
<#+
			}

			bool stringProp = CodeGenerationUtilities.IsStringProperty(elementProp);
			if (!stringProp)
			{
#>
			string serializedPropValue = DslModeling::SerializationUtilities.GetString<<#= elementProp.Type.GetRelativeName(namespaceString, true) #>>(serializationContext, propValue);
<#+
				propValueInstance = "serializedPropValue";
			}
#>
			if (!serializationContext.Result.Failed)
			{
<#+
			string elementPropTagName = CodeGenerationUtilities.GetPropertyTagName (elementProp);
			if ((monikerDataDC.KeyProperty != null && monikerDataDC.KeyProperty.Id == elementProp.Id) ||
				(monikerDataDC.QualifierProperty != null && monikerDataDC.QualifierProperty.Id == elementProp.Id))
			{
#>
				<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.WriteElementString(serializationContext, element, writer, "<#= elementPropTagName #>", <#= propValueInstance #>);

<#+
			}
			else if (elementProp.DefaultValue == null)
			{
				if (!stringProp)
				{
#>
			<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.WriteElementString(serializationContext, element, writer, "<#= elementPropTagName #>", <#= propValueInstance #>);
<#+
				}
				else if (elementProp.Kind == PropertyKind.Normal)
				{
#>
				if (!string.IsNullOrEmpty(<#= propValueInstance #>))
				<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.WriteElementString(serializationContext, element, writer, "<#= elementPropTagName #>", <#= propValueInstance #>);

<#+
				}
				else
				{
#>
				if (<#= propValueInstance #> != null)
					<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.WriteElementString(serializationContext, element, writer, "<#= elementPropTagName #>", <#= propValueInstance #>);
<#+
				}
			}
			else
			{	// Generate code to check if the property is the same as default value, if so, there's no need to write the value out.
				if (stringProp)
				{
#>
				if (<#= propValueInstance #> != null && (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(<#= propValueInstance #>, <#= CodeGenerationUtilities.WrapAsCSharpString(elementProp.DefaultValue) #>) != 0))
				{	// No need to write the value out if it's the same as default value.
					<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.WriteElementString(serializationContext, element, writer, "<#= elementPropTagName #>", <#= propValueInstance #>);

				}
<#+
				}
				else
				{
#>
				if (serializationContext.WriteOptionalPropertiesWithDefaultValue || string.CompareOrdinal(<#= propValueInstance #>, <#= CodeGenerationUtilities.WrapAsCSharpString(elementProp.DefaultValue) #>) != 0)
				{	// No need to write the value out if it's the same as default value.
					<#= behavior.DslLibrary.Name #>SerializationHelper.Instance.WriteElementString(serializationContext, element, writer, "<#= elementPropTagName #>", <#= propValueInstance #>);
				}
<#+
				}
			}
#>
			}
		}
<#+
		}
#>
	} 
<#+
	}

	if (generateChildElementsMethods)
	{
#>

	/// <summary>
	/// Serialize all child model elements.
	/// </summary>
	/// <param name="serializationContext">Serialization context.</param>
	/// <param name="element"><#= domainClass.Name #> instance to be serialized.</param>
	/// <param name="writer">XmlWriter to write serialized data to.</param>
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Generated code.")]
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Generated code.")]		
	private static void WriteChildElements(DslModeling::SerializationContext serializationContext, <#= classTypeString #> element, global::System.Xml.XmlWriter writer)
	{
<#+
		// The "roles" are already sorted here, after generating the ReadElements() method above.
		uint count = 0;
		foreach(DomainRole role in roles)
		{
			if (count++ > 0)
			{	// Print an empty line between each relationship.
#>

<#+
			}
			
			DomainRelationship rel = role.Relationship;
			string relName = rel.Name;
			string relType = role.Relationship.GetRelativeName(namespaceString, true);
			string relTagName = CodeGenerationUtilities.GetRelationshipTagName (role);
			DomainRole childRole = role.Opposite;
			string childRoleType = childRole.RolePlayer.GetRelativeName(namespaceString, true);
			bool omitElement = CodeGenerationUtilities.OmitElement (rel);
			bool useFullForm = CodeGenerationUtilities.UseFullForm (rel);
			bool sealedRel = (rel.InheritanceModifier == InheritanceModifier.Sealed);

			if (!sealedRel || useFullForm)
			{	// If a relationship is not sealed, it can be derived from. The derived ones will be serialized 
				// using full-form, even though the relationship itself won't (unless UseFullForm is set to true). 	
				string instanceName = ("each" + relName.TrimStart('@') + "Instance");
				string allInstancesName = ("all" + relName.TrimStart('@') + "Instances");
				bool allowMultiple = CodeGenerationUtilities.AllowMultiple(role);
#>
		// <#= relName #>
<#+
				if (role.PropertyGetterAccessModifier != AccessModifier.Public)
				{
#>
		// Non-public getter, use DomainRoleInfo methods.
		global::System.Collections.ObjectModel.ReadOnlyCollection<<#= relType #>> <#= allInstancesName #> = DslModeling::DomainRoleInfo.GetElementLinks<<#= relType #>>(element, <#= relType #>.<#= role.Name #>DomainRoleId);
<#+
					if (allowMultiple)
					{	
#>
		if (!serializationContext.Result.Failed && <#= allInstancesName #>.Count > 0)
<#+
					}
					else
					{
						instanceName = ("the" + relName.TrimStart('@') + "Instance");
#>
		<#= relType #> <#= instanceName #> = null;
		if (<#= allInstancesName #>.Count > 0)
		{
			<#= instanceName #> = <#= allInstancesName #>[0];
		}
		if (!serializationContext.Result.Failed && <#= instanceName #> != null)
<#+
					}
				}
				else if (allowMultiple)
				{	
#>
		global::System.Collections.ObjectModel.ReadOnlyCollection<<#= relType #>> <#= allInstancesName #> = <#= relType #>.GetLinksTo<#= role.PropertyName.TrimStart('@') #>(element);
		if (!serializationContext.Result.Failed && <#= allInstancesName #>.Count > 0)
<#+
				}
				else
				{
					instanceName = ("the" + relName.TrimStart('@') + "Instance");
#>
		<#= relType #> <#= instanceName #> = <#= relType #>.GetLinkTo<#= role.PropertyName.TrimStart('@') #>(element);
		if (!serializationContext.Result.Failed && <#= instanceName #> != null)
<#+
				}
#>
		{
<#+
				if (!useFullForm && !rel.IsEmbedding)
				{	// The serializer for the base relationship itself will be used in these cases.
#>
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(<#= relType #>.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for <#= relName #>!");

<#+
				}
				if (!omitElement)
				{
#>
			writer.WriteStartElement("<#= relTagName #>");
<#+
				}
				if (!useFullForm && !sealedRel)
				{
#>
			global::System.Type typeof<#= relName.TrimStart('@') #> = typeof(<#= relType #>);
<#+
				}
				if (allowMultiple)
				{
#>
			foreach (<#= relType #> <#= instanceName #> in <#= allInstancesName #>)
			{
				if (serializationContext.Result.Failed)
					break;

<#+
					PushIndent("\t");
				}			
				if (useFullForm)
				{	// If the relationship is set to use full-form, all instances will be in full-form.
#>
			DslModeling::DomainClassXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(<#= instanceName #>.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for " + <#= instanceName #>.GetDomainClass().Name + "!");
			relSerializer.Write(serializationContext, <#= instanceName #>, writer);
<#+
				}
				else
				{	// Otherwise only derived ones will be in full-form.
					if (!sealedRel)
					{
#>
			if (<#= instanceName #>.GetType() != typeof<#= relName.TrimStart('@') #>)
			{	// Derived relationships will be serialized in full-form.
				DslModeling::DomainClassXmlSerializer derivedRelSerializer = serializationContext.Directory.GetSerializer(<#= instanceName #>.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(derivedRelSerializer != null, "Cannot find serializer for " + <#= instanceName #>.GetDomainClass().Name + "!");			
				derivedRelSerializer.Write(serializationContext, <#= instanceName #>, writer);
			}
			else
			{	// No need to serialize the relationship itself, just serialize the role-player directly.
<#+
						PushIndent("\t");
					}
#>
			DslModeling::ModelElement targetElement = <#= instanceName #>.<#= childRole.Name #>;
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(targetElement.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + targetElement.GetDomainClass().Name + "!");			
<#+
					if(!rel.IsEmbedding)
					{
#>
			targetSerializer.WriteMoniker(serializationContext, targetElement, writer, element, relSerializer);
<#+
					}
					else
					{
#>
			targetSerializer.Write(serializationContext, targetElement, writer);
<#+
					}
					if (!sealedRel)
					{
						PopIndent();
#>
			}
<#+
					}
				}
				if (allowMultiple)
				{
					PopIndent();
#>
			}
<#+
				}
				if (!omitElement)
				{
#>
			writer.WriteEndElement();
<#+
				}
#>
		}

<#+
			}
			else
			{	// The relationship itself doesn't need to be serialized explicitly, just serialize the target roles.
				if (CodeGenerationUtilities.AllowMultiple (role))
				{	// Serialize each instance
					string instanceName = ("each" + childRole.RolePlayer.Name.TrimStart('@') + "Of" + relName.TrimStart('@'));
					string allInstancesName = ("all" + childRole.RolePlayer.Name.TrimStart('@') + "InstancesOf" + relName.TrimStart('@'));
					
#>
		// <#= relName #>
		DslModeling::LinkedElementCollection<<#= childRoleType #>> <#= allInstancesName #> = <#= relType #>.Get<#= role.PropertyName.TrimStart('@') #>(element);
		if (!serializationContext.Result.Failed && <#= allInstancesName #>.Count > 0)
		{
<#+
					if (!rel.IsEmbedding)
					{	// The serializer for the relationship will be used for referenced relationship.
#>
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(<#= relType #>.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for <#= relName #>!");

<#+
					}
					if (!omitElement)
					{
#>
			writer.WriteStartElement("<#= relTagName #>");
<#+
					}
#>
			foreach (<#= childRoleType #> <#= instanceName #> in <#= allInstancesName #>)
			{
				if (serializationContext.Result.Failed)
					break;

				DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(<#= instanceName #>.GetDomainClass().Id);
				global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + <#= instanceName #>.GetDomainClass().Name + "!");			
<#+
						if(!rel.IsEmbedding)
						{
#>
				targetSerializer.WriteMoniker(serializationContext, <#= instanceName #>, writer, element, relSerializer);
<#+
						}
						else
						{
#>
				targetSerializer.Write(serializationContext, <#= instanceName #>, writer);
<#+
						}
#>
			}
<#+
					if (!omitElement)
					{
#>
			writer.WriteEndElement();
<#+
					}
#>
		}
			
<#+
				}
				else
				{	// Single child instance
					string instanceName = ("single" + childRole.RolePlayer.Name.TrimStart('@') + "InstanceOf" + relName.TrimStart('@'));
#>
		// <#= relName #>
		<#= childRoleType #> <#= instanceName #> = <#= relType #>.Get<#= role.PropertyName.TrimStart('@') #>(element);
		if (!serializationContext.Result.Failed && <#= instanceName #> != null)
		{
<#+
					if (!rel.IsEmbedding)
					{	// The serializer for the relationship will be used for reference relationship.
#>
			DslModeling::DomainRelationshipXmlSerializer relSerializer = serializationContext.Directory.GetSerializer(<#= relType #>.DomainClassId) as DslModeling::DomainRelationshipXmlSerializer;
			global::System.Diagnostics.Debug.Assert(relSerializer != null, "Cannot find serializer for <#= relName #>!");

<#+
					}
					if (!omitElement)
					{
#>
			writer.WriteStartElement("<#= relTagName #>");
<#+
					}
#>
			DslModeling::DomainClassXmlSerializer targetSerializer = serializationContext.Directory.GetSerializer(<#= instanceName #>.GetDomainClass().Id);
			global::System.Diagnostics.Debug.Assert(targetSerializer != null, "Cannot find serializer for " + <#= instanceName #>.GetDomainClass().Name + "!");			

<#+
					if(!rel.IsEmbedding)
					{
#>
			targetSerializer.WriteMoniker(serializationContext, <#= instanceName #>, writer, element, relSerializer);
<#+
					}
					else
					{
#>
			targetSerializer.Write(serializationContext, <#= instanceName #>, writer);
<#+
					}

					if (!omitElement)
					{
#>
			writer.WriteEndElement();
<#+
					}
#>
		}

<#+
				}
			}
		}
#>
	}
<#+
	}
#>
	#endregion
<#+	
	if (!monikerizationSupportOnly && !readSupportOnly)
	{
		GenerateMonikerOverrides(behavior, domainClass, isCustom);
	}

	if (isRelationship && (monikerizationSupportOnly || !readSupportOnly))
	{
		GenerateRelationshipMonikerSupport(behavior, domainClass as DomainRelationship);
	}
	if (isRelationship)
	{
	  // Relationship serializers flag metadata for whether they are doing SerializeId, UseFullForm
#>	
	#region Overrides to provide metadata at runtime
	/// <summary>
	/// Exposes whether serializers derived from this class are serializing Id.
	/// </summary>
	public override bool SerializesId
	{
		get
		{
			return <#= monikerDataDC.SerializeId.ToString().ToLowerInvariant() #>;
		}
	}

	/// <summary>
	/// Exposes whether serializers derived from this class are serializing this relationship in full form.
	/// </summary>
	public override bool UsesFullForm
	{
		get
		{
			return <#= CodeGenerationUtilities.UseFullForm(domainClass as DomainRelationship).ToString().ToLowerInvariant() #>;
		}
	}
	#endregion
<#+
	}
	// Close class declaration:
#>
}
<#+
	if (domainClass.GeneratesDoubleDerived)
	{
#>

/// <summary>
/// Serializer <#= serializerClassName #> for DomainClass <#= domainClass.GetRelativeName(namespaceString, false) #>.
/// </summary>
<#+
		if (inheritanceDepth > 5)
		{
#>
[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1501:AvoidExcessiveInheritance", Justification = "Generated code.")]
<#+
		}
#>
<#= CodeGenerationUtilities.GetTypeAccessModifier(domainClass.AccessModifier) #><#= domainClass.InheritanceModifier == InheritanceModifier.Sealed ? " sealed" : string.Empty #> partial class <#= serializerClassName #> : <#= serializerGenerationClassName #>
{
	#region Constructor
	/// <summary>
	/// <#= serializerClassName #> Constructor
	/// </summary>
	public <#= serializerClassName #> ()
		: base ()
	{
	}
	#endregion
}
<#+
	}

	if(!string.IsNullOrEmpty(namespaceString))
	{ // close namespace declaration:
		PopIndent();
#>
}

<#+
	}

	return serializerClassName;
}



private void GenerateResetMethod(bool isSealed)
{
	// Override the Reset method if this class could have derived classes.
	if (!isSealed)
	{

#>
	
	#region Miscellaneous methods

	/// <summary>
	/// Reset the serializer
	/// </summary>
	/// <remarks>
	/// Clear the cached information about any derived classes so that it is recalculated.
	/// </remarks>
	public override void Reset()
	{
		base.Reset();
		this.derivedClasses = null;
		this.derivedClassMonikers = null;
	}

	#endregion

<#+

	}
} // GenerateResetMethod()
#>

