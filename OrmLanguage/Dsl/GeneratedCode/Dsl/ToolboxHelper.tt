<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ output extension=".cs" #>
<#
	string dslName = this.DslLibrary.Name;
	
	DomainClass rootClass = (this.IsDsl && this.Dsl.Editor != null) ? this.Dsl.Editor.RootClass : null;
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDesign = global::Microsoft.VisualStudio.Modeling.Design;
using System;
using System.Diagnostics;
using System.Drawing.Design;
using System.Windows.Forms;
<#
	if(this.IsDsl && this.Dsl.Editor.ToolboxTabs.Count > 0)
	{
#>
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;
<#
	}
	
	Designer designer = CodeGenerationUtilities.GetDesigner(this.DslLibrary);
	bool stickyToolbox = (designer != null ? designer.UsesStickyToolboxItems : false);
#>

namespace <#= this.DslLibrary.Namespace #>
{
	/// <summary>
	/// Helper class used to create and initialize toolbox items for this DSL.
	/// </summary>
	/// <remarks>
	/// Double-derived class to allow easier code customization.
	/// </remarks>
	<#= rootClass != null ? CodeGenerationUtilities.GetTypeAccessModifier(rootClass.AccessModifier) : "internal" #> partial class <#= dslName #>ToolboxHelper : <#= dslName #>ToolboxHelperBase 
	{
		/// <summary>
		/// Constructs a new <#= dslName #>ToolboxHelper.
		/// </summary>
		public <#= dslName #>ToolboxHelper(global::System.IServiceProvider serviceProvider)
			: base(serviceProvider) { }
	}
	
	/// <summary>
	/// Helper class used to create and initialize toolbox items for this DSL.
	/// </summary>
<#
if (this.IsDsl && this.Dsl.Editor.ToolboxTabs.Count > 0)
	{
#>	
	[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable", Justification = "The store is disposed on domain shut down")]
<#
	}
#>
	<#= rootClass != null ? CodeGenerationUtilities.GetTypeAccessModifier(rootClass.AccessModifier) : "internal" #> abstract class <#= dslName #>ToolboxHelperBase
	{
		/// <summary>
		/// Toolbox item filter string used to identify <#= dslName #> toolbox items.  
		/// </summary>
		/// <remarks>
		/// See the MSDN documentation for the ToolboxItemFilterAttribute class for more information on toolbox
		/// item filters.
		/// </remarks>
		public const string ToolboxFilterString = "<#= dslName #>.<#= this.DslLibrary.MajorVersion #>.<#= this.DslLibrary.MinorVersion #>";
<#
	if (this.IsDsl)
	{
		foreach(ToolboxTab tab in this.Dsl.Editor.ToolboxTabs)
		{
			foreach(Tool tool in tab.Tools)
			{
				ConnectionTool connectionTool = tool as ConnectionTool;
				if(connectionTool != null)
				{
#>
		/// <summary>
		/// Toolbox item filter string used to identify <#= tool.Name #> connector tool.
		/// </summary>
		public const string <#= tool.Name #>FilterString = "<#= tool.Name #>.<#= this.DslLibrary.MajorVersion #>.<#= this.DslLibrary.MinorVersion #>";
<#
				}
				else if (stickyToolbox)
				{
					ElementTool elementTool = tool as ElementTool;
					if (elementTool != null)
					{
#>
		/// <summary>
		/// Toolbox item filter string used to identify <#= tool.Name #> element tool.
		/// </summary>
		public const string <#= tool.Name #>FilterString = "<#= tool.Name #>.<#= this.DslLibrary.MajorVersion #>.<#= this.DslLibrary.MinorVersion #>";
<#
					}
				}
			}
		}
	}
#>

<#
if (this.IsDsl && this.Dsl.Editor.ToolboxTabs.Count > 0)
	{
#>	
		private global::System.Collections.Generic.Dictionary<string, DslDesign::ModelingToolboxItem> toolboxItemCache = new global::System.Collections.Generic.Dictionary<string, DslDesign::ModelingToolboxItem>();
		private DslModeling::Store toolboxStore;
		
<#
	}
#>
		private global::System.IServiceProvider sp;
		
		/// <summary>
		/// Constructs a new <#= dslName #>ToolboxHelperBase.
		/// </summary>
		protected <#= dslName #>ToolboxHelperBase(global::System.IServiceProvider serviceProvider)
		{
			if(serviceProvider == null) throw new global::System.ArgumentNullException("serviceProvider");
			
			this.sp = serviceProvider;
		}
		
		/// <summary>
		/// Serivce provider used to access services from the hosting environment.
		/// </summary>
		protected global::System.IServiceProvider ServiceProvider
		{
			get
			{
				return this.sp;
			}
		}

		/// <summary>
		/// Returns the display name of the tab that should be opened by default when the editor is opened.
		/// </summary>
		public static string DefaultToolboxTabName
		{
			get
			{
<#
	if(this.IsDsl && this.Dsl.Editor.ToolboxTabs.Count > 0)
	{
		// There's no point of making the default toolbox tab to be the one which has no toolbox items. Therefore,
		// we will find the 1st tab which has toolbox item(s) in it. If not, we have no choice but to pick the very
		// first one among the collection.
		string toolTabId = string.Empty;
		foreach(ToolboxTab tab in this.Dsl.Editor.ToolboxTabs)
		{
			if (tab.Tools.Count != 0)
			{
				toolTabId = tab.TabText + "ToolboxTab";
				break;
			}
		}				
		
		// If every tab has no toolbox items, simply pick the first one.
		if ( toolTabId.Length == 0 )
		{
			toolTabId = this.Dsl.Editor.ToolboxTabs[0].TabText + "ToolboxTab";
		}
#>
				return <#= this.Dsl.GetFullName(true) #>DomainModel.SingletonResourceManager.GetString("<#= toolTabId #>", global::System.Globalization.CultureInfo.CurrentUICulture);
<#
	}
	else
	{
#>
				return string.Empty;
<#
	}
#>
			}
		}
		
		
		/// <summary>
		/// Returns the toolbox items count in the default tool box tab.
		/// </summary>
		public static int DefaultToolboxTabToolboxItemsCount
		{
			get
			{
<#
	if(this.IsDsl && this.Dsl.Editor.ToolboxTabs.Count > 0)
	{
		// There's no point of making the default toolbox tab to be the one which has no toolbox items. Therefore,
		// we will find the 1st tab which has toolbox item(s) in it. If not, we have no choice but to pick the very
		// first one among the collection.
		int count = 0;
		foreach(ToolboxTab tab in this.Dsl.Editor.ToolboxTabs)
		{
			if (tab.Tools.Count != 0)
			{
				count = tab.Tools.Count;
				break;
			}
		}				
		
		// If every tab has no toolbox items, simply pick the first one.
		if ( count == 0 )
		{
			count = this.Dsl.Editor.ToolboxTabs[0].Tools.Count;
		}
#>
				return <#= count.ToString(System.Globalization.CultureInfo.InvariantCulture) #>;
<#
	}
	else
	{
#>
				return 0;
<#
	}
#>
			}
		}
		

		/// <summary>
		/// Returns a list of custom toolbox items to be added dynamically
		/// </summary>
		public virtual global::System.Collections.Generic.IList<DslDesign::ModelingToolboxItem> CreateToolboxItems()
		{
			global::System.Collections.Generic.List<DslDesign::ModelingToolboxItem> toolboxItems = new global::System.Collections.Generic.List<DslDesign::ModelingToolboxItem>();
			return toolboxItems;
		}
		
		/// <summary>
		/// Creates an ElementGroupPrototype for the element tool corresponding to the given domain class id.
		/// Default behavior is to create a prototype containing an instance of the domain class.
		/// Derived classes may override this to add additional information to the prototype.
		/// </summary>
		protected virtual DslModeling::ElementGroupPrototype CreateElementToolPrototype(DslModeling::Store store, global::System.Guid domainClassId)
		{
			DslModeling::ModelElement element = store.ElementFactory.CreateElement(domainClassId);
			DslModeling::ElementGroup elementGroup = new DslModeling::ElementGroup(store.DefaultPartition);
			elementGroup.AddGraph(element, true);
			return elementGroup.CreatePrototype();
		}

		/// <summary>
		/// Returns instance of ModelingToolboxItem based on specified name.
		/// This method must be called from within a Transaction. Failure to do so will result in an exception
		/// </summary>
		/// <param name="itemId">unique name of desired ToolboxItem</param>
		/// <param name="store">Store to perform the operation against</param>
		/// <returns>An instance of ModelingToolboxItem if the itemId can be resolved, null otherwise</returns>
		public virtual DslDesign::ModelingToolboxItem GetToolboxItem(string itemId, DslModeling::Store store)
		{
			DslDesign::ModelingToolboxItem result = null;
			if (string.IsNullOrEmpty(itemId))
			{
				return null;
			}
			if (store == null)
			{
				return null;
			}
<#
	if (this.IsDsl)
	{
		if (this.Dsl.Editor.ToolboxTabs.Count > 0)
		{
#>
			global::System.Resources.ResourceManager resourceManager = <#= this.Dsl.GetFullName(true) #>DomainModel.SingletonResourceManager;
			global::System.Globalization.CultureInfo resourceCulture = global::System.Globalization.CultureInfo.CurrentUICulture;
			switch(itemId)
			{
<#
			foreach(ToolboxTab tab in this.Dsl.Editor.ToolboxTabs)
			{
				int toolboxOrder = 0;
				string toolTabId = tab.TabText + "ToolboxTab";
				foreach(Tool tool in tab.Tools)
				{
					toolboxOrder++;
					string toolId = tool.Name + "ToolboxItem";
					string tooltipId = tool.Name + "ToolboxTooltip";
					string toolBitmapId = tool.Name + "ToolboxBitmap";
					string helpKeyword = tool.HelpKeyword != null ? tool.HelpKeyword : String.Empty;
#>
				case "<#= CodeGenerationUtilities.GetPackageNamespace(this.Dsl) #>.<#= toolId #>":
<#					
					ElementTool elementTool = tool as ElementTool;
					if(elementTool != null)
					{
#>
					// Add <#= tool.Name #> shape tool.
					result = new DslDesign::ModelingToolboxItem(
						"<#= CodeGenerationUtilities.GetPackageNamespace(this.Dsl) #>.<#= toolId #>", // Unique identifier (non-localized) for the toolbox item.
						<#= toolboxOrder #>, // Position relative to other items in the same toolbox tab.
						resourceManager.GetString("<#= toolId #>", resourceCulture), // Localized display name for the item.
						(global::System.Drawing.Bitmap)DslDiagrams::ImageHelper.GetImage(resourceManager.GetObject("<#= toolBitmapId #>", resourceCulture)), // Image displayed next to the toolbox item.
						"<#= CodeGenerationUtilities.GetPackageNamespace(this.Dsl) #>.<#= toolTabId #>", // Unique identifier (non-localized) for the toolbox item tab.
						resourceManager.GetString("<#= toolTabId #>", resourceCulture), // Localized display name for the toolbox tab.
						"<#= helpKeyword #>", // F1 help keyword for the toolbox item.
						resourceManager.GetString("<#= tooltipId #>", resourceCulture), // Localized tooltip text for the toolbox item.
						CreateElementToolPrototype(store, <#= elementTool.Class.GetFullName(true) #>.DomainClassId), // ElementGroupPrototype (data object) representing model element on the toolbox.
						new global::System.ComponentModel.ToolboxItemFilterAttribute[] { // Collection of ToolboxItemFilterAttribute objects that determine visibility of the toolbox item.
<#
						if (stickyToolbox)
						{
#>
						new global::System.ComponentModel.ToolboxItemFilterAttribute(ToolboxFilterString, global::System.ComponentModel.ToolboxItemFilterType.Require),
						new global::System.ComponentModel.ToolboxItemFilterAttribute(<#= tool.Name #>FilterString)
<#
						}
						else
						{
#>
						new global::System.ComponentModel.ToolboxItemFilterAttribute(ToolboxFilterString, global::System.ComponentModel.ToolboxItemFilterType.Require) 
<#
						}
#>
						});
<#
				}
				else
				{
					ConnectionTool connectionTool = tool as ConnectionTool;
					if (connectionTool != null)
					{
#>

					// Add <#= tool.Name #> connector tool.
					result = new DslDesign::ModelingToolboxItem(
						"<#= CodeGenerationUtilities.GetPackageNamespace(this.Dsl) #>.<#= toolId #>", // Unique identifier (non-localized) for the toolbox item.
						<#= toolboxOrder #>, // Position relative to other items in the same toolbox tab.
						resourceManager.GetString("<#= toolId #>", resourceCulture), // Localized display name for the item.
						(global::System.Drawing.Bitmap)DslDiagrams::ImageHelper.GetImage(resourceManager.GetObject("<#= toolBitmapId #>", resourceCulture)), // Image displayed next to the toolbox item.				
						"<#= CodeGenerationUtilities.GetPackageNamespace(this.Dsl) #>.<#= toolTabId #>", // Unique identifier (non-localized) for the toolbox item tab.
						resourceManager.GetString("<#= toolTabId #>", resourceCulture), // Localized display name for the toolbox tab.
						"<#= helpKeyword #>", // F1 help keyword for the toolbox item.
						resourceManager.GetString("<#= tooltipId #>", resourceCulture), // Localized tooltip text for the toolbox item.
						null, // Connector toolbox items do not have an underlying data object.
						new global::System.ComponentModel.ToolboxItemFilterAttribute[] { // Collection of ToolboxItemFilterAttribute objects that determine visibility of the toolbox item.
							new global::System.ComponentModel.ToolboxItemFilterAttribute(ToolboxFilterString, global::System.ComponentModel.ToolboxItemFilterType.Require), 
							new global::System.ComponentModel.ToolboxItemFilterAttribute(<#= tool.Name #>FilterString)
						});
<#
					}
				}
#>
					break;
<#			
				}
			}
#>
				default:
					break;
			} // end switch
<#
		}
	}
#>
			
			return result;
		}
<#
	if (this.IsDsl)
	{
		if (this.Dsl.Editor.ToolboxTabs.Count > 0)
		{
#>		

		/// <summary>
		/// The store toe be used for all the toolbox item creation
		/// </summary>
		protected DslModeling::Store ToolboxStore
		{
			get
			{ 
				if (toolboxStore==null)
				{
					toolboxStore = new DslModeling::Store(this.ServiceProvider);
					EventHandler StoreCleanUp = (o, e) =>
					{
						//Since Store implements IDisposable, we need to dispose it when we're finished
						if (this.toolboxStore != null)
						{
							this.toolboxStore.Dispose();
						}
						this.toolboxStore = null;
					};
					//There is no DomainUnload event for the default AppDomain, so we listen for both ProcessExit and DomainUnload
					AppDomain.CurrentDomain.ProcessExit += new EventHandler(StoreCleanUp);
					AppDomain.CurrentDomain.DomainUnload += new EventHandler(StoreCleanUp);
					
					//load the domain model
					toolboxStore.LoadDomainModels(typeof(<#= this.Dsl.GetFullName(true) #>DomainModel));
					
				}
				return toolboxStore;
			}
		}
		
		/// <summary>
		/// Given a toolbox item "unique ID" returns the the toolbox item using cached dictionary
		/// </summary>
		/// <param name="itemId">The unique ToolboxItem to retrieve</param>
		private DslDesign::ModelingToolboxItem GetToolboxItem(string itemId)
		{
			DslDesign::ModelingToolboxItem item = null;

			if (!this.toolboxItemCache.TryGetValue(itemId, out item))
			{
				DslModeling::Store store = this.ToolboxStore;
				
				// Open transaction so we can create model elements corresponding to toolbox items.
				using (DslModeling::Transaction t = store.TransactionManager.BeginTransaction("CreateToolboxItems"))
				{
					// Retrieve the specified ToolboxItem from the DSL
					this.toolboxItemCache[itemId] = item = this.GetToolboxItem(itemId, store);
				}
			}

			return item;
		}
		
		/// <summary>
		/// Given a toolbox item "unique ID" and a data format identifier, returns the content of
		/// the data format. 
		/// </summary>
		/// <param name="itemId">The unique ToolboxItem to retrieve data for</param>
		/// <param name="format">The desired format of the resulting data</param>
		public virtual object GetToolboxItemData(string itemId, DataFormats.Format format)
		{
			DslDesign::ModelingToolboxItem item = null;

			global::System.Resources.ResourceManager resourceManager = <#= this.Dsl.GetFullName(true) #>DomainModel.SingletonResourceManager;
			global::System.Globalization.CultureInfo resourceCulture = global::System.Globalization.CultureInfo.CurrentUICulture;

			System.Windows.Forms.IDataObject tbxDataObj;

			//get the toolbox item
			item = GetToolboxItem(itemId);

			if (item != null)
			{
				ToolboxItemContainer container = new ToolboxItemContainer(item);
				tbxDataObj = container.ToolboxData;

				if (tbxDataObj.GetDataPresent(format.Name))
				{
					return tbxDataObj.GetData(format.Name);
				}
				else 
				{
					string invalidFormatString = resourceManager.GetString("UnsupportedToolboxFormat", resourceCulture);
					throw new InvalidOperationException(string.Format(resourceCulture, invalidFormatString, format.Name));
				}
			}

			string errorFormatString = resourceManager.GetString("UnresolvedToolboxItem", resourceCulture);
			throw new InvalidOperationException(string.Format(resourceCulture, errorFormatString, itemId));
		}		
<#
		}
	}
#>	}
}
